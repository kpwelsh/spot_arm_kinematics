/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2022-11-10 18:05:41.648068
/// Generated using solver transform6d
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
// #define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
// IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan std::isnan
#endif
#ifndef isinf
#define isinf std::isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKcos(j[2]);
x3=IKsin(j[1]);
x4=IKsin(j[2]);
x5=IKsin(j[0]);
x6=IKsin(j[3]);
x7=IKcos(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKcos(j[5]);
x11=IKsin(j[5]);
x12=((1.0)*x8);
x13=((0.0675)*x1);
x14=((0.38609)*x3);
x15=((0.081)*x5);
x16=((1.0)*x9);
x17=((1.0)*x6);
x18=((0.0075)*x7);
x19=((0.081)*x0);
x20=((1.0)*x5);
x21=(x0*x4);
x22=(x3*x4);
x23=(x1*x5);
x24=(x7*x8);
x25=(x1*x2);
x26=(x1*x4);
x27=(x2*x3);
x28=(x4*x5);
x29=(x0*x17);
x30=((1.0)*x22);
x31=((0.0075)*x27);
x32=((((-1.0)*x30))+x25);
x33=((((-1.0)*x26))+(((-1.0)*x27)));
x34=(x32*x6);
x35=(((x0*x27))+((x1*x21)));
x36=((((-1.0)*x21*x3))+((x0*x25)));
x37=(((x27*x5))+((x23*x4)));
x38=(((x2*x23))+(((-1.0)*x20*x22)));
x39=(x33*x8);
x40=(x32*x7*x9);
x41=(x36*x8);
x42=(x37*x7);
x43=(x35*x7);
x44=(((x5*x6))+x43);
x45=(((x35*x6))+(((-1.0)*x20*x7)));
x46=((((-1.0)*x29))+x42);
x47=(((x0*x7))+((x37*x6)));
x48=(x46*x9);
eerot[0]=(((x10*x45))+((x11*((x41+((x44*x9)))))));
eerot[1]=(((x36*x9))+((x8*(((((-1.0)*x43))+(((-1.0)*x17*x5)))))));
eerot[2]=(((x10*(((((-1.0)*x12*x36))+(((-1.0)*x16*x44))))))+((x11*x45)));
eetrans[0]=((0.29)+((x8*(((((-0.081)*x43))+(((-1.0)*x15*x6))))))+((x18*x5))+((x9*((((x19*x25))+(((-1.0)*x19*x22))))))+((x6*(((((-1.0)*x0*x31))+(((-0.0075)*x1*x21))))))+(((0.38609)*x0*x25))+(((0.0675)*x0*x27))+(((-1.0)*x14*x21))+(((0.3125)*x0*x1))+(((0.001)*x5))+((x13*x21)));
eerot[3]=(((x10*x47))+((x11*((x48+((x38*x8)))))));
eerot[4]=(((x8*(((((-1.0)*x42))+x29))))+((x38*x9)));
eerot[5]=(((x11*x47))+((x10*(((((-1.0)*x12*x38))+(((-1.0)*x16*x46)))))));
eetrans[1]=((((0.0675)*x27*x5))+(((0.38609)*x2*x23))+(((-1.0)*x0*x18))+((x8*(((((-0.081)*x42))+((x19*x6))))))+((x9*(((((-1.0)*x15*x22))+((x15*x25))))))+(((-1.0)*x14*x28))+((x13*x28))+(((0.3125)*x23))+((x6*(((((-1.0)*x31*x5))+(((-0.0075)*x23*x4))))))+(((-0.001)*x0)));
eerot[6]=(((x10*x34))+((x11*((x39+x40)))));
eerot[7]=(((x24*(((((-1.0)*x25))+x30))))+((x33*x9)));
eerot[8]=(((x10*(((((-1.0)*x39))+(((-1.0)*x40))))))+((x11*x34)));
eetrans[2]=((0.195)+((x24*(((((-0.081)*x25))+(((0.081)*x22))))))+(((-0.3125)*x3))+((x6*(((((-0.0075)*x25))+(((0.0075)*x22))))))+(((-1.0)*x14*x2))+(((-0.38609)*x26))+((x9*(((((-0.081)*x27))+(((-0.081)*x26))))))+((x13*x2))+(((-0.0675)*x22)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=((-1.0)*r02);
new_r02=r01;
new_px=((-0.29)+px+(((-0.081)*r01)));
new_r10=r10;
new_r11=((-1.0)*r12);
new_r12=r11;
new_py=(py+(((-0.081)*r11)));
new_r20=r20;
new_r21=((-1.0)*r22);
new_r22=r21;
new_pz=((-0.195)+pz+(((-0.081)*r21)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x49=((1.0)*px);
IkReal x50=((1.0)*pz);
IkReal x51=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x51))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x50)));
rxp0_2=((((-1.0)*r10*x49))+((py*r00)));
rxp1_0=((((-1.0)*r21*x51))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x50)));
rxp1_2=((((-1.0)*r11*x49))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x51)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x50)));
rxp2_2=((((-1.0)*r12*x49))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x52=((1000.0)*rxp2_0);
IkReal x53=((1.0)*r22);
IkReal x54=((7.5)*r01);
IkReal x55=((111.111111111111)*npx);
IkReal x56=((1000.0)*rxp2_1);
IkReal x57=((5719.85185185185)*npz);
IkReal x58=((7407.40740740741)*pp);
IkReal x59=((7.5)*r11);
IkReal x60=((0.0075)*r21);
IkReal x61=((0.001)*r02);
IkReal x62=((1.0)*rxp2_2);
IkReal x63=((15.0)*r10);
IkReal x64=((222.222222222222)*npy);
IkReal x65=((2.0)*r21);
IkReal x66=((15.0)*r02);
IkReal x67=((2000.0)*rxp1_0);
IkReal x68=((11439.7037037037)*npy);
IkReal x69=((15.0)*r12);
IkReal x70=((2000.0)*rxp1_1);
IkReal x71=((2.0)*rxp1_2);
IkReal x72=((0.002)*r01);
IkReal x73=((0.015)*r22);
IkReal x74=((4000.0)*rxp0_1);
IkReal x75=((22879.4074074074)*npx);
IkReal x76=((4000.0)*rxp0_0);
IkReal x77=((4.0)*r20);
IkReal x78=((0.004)*r00);
IkReal x79=((4.0)*rxp0_2);
IkReal x80=((0.002)*r11);
IkReal x81=((0.001)*r12);
IkReal x82=((15.0)*r00);
IkReal x83=((0.015)*r20);
IkReal x84=((-0.001)*r12);
IkReal x85=((-0.015)*r20);
IkReal x86=((-0.002)*r11);
IkReal x87=((-0.004)*r10);
IkReal x88=((-15.0)*r00);
IkReal x89=(rxp2_2+x61);
IkReal x90=((-414.96843037037)+x57);
IkReal x91=((414.96843037037)+x57);
IkReal x92=(x54+x52);
IkReal x93=(x63+x64);
IkReal x94=(x60+x61);
IkReal x95=(x73+x72);
IkReal x96=(x66+x67);
IkReal x97=(x58+x56);
IkReal x98=(x58+x55);
IkReal x99=(x55+x56);
IkReal x100=(x60+x62);
IkReal x101=(x59+x55);
IkReal x102=(x70+x69);
IkReal x103=(x59+x58);
IkReal x104=(x59+x56);
op[0]=(x92+(((-1.0)*x53)));
op[1]=(x104+x90+(((-1.0)*x98)));
op[2]=x82;
op[3]=x93;
op[4]=(x52+(((-1.0)*x54))+(((-1.0)*x53)));
op[5]=((((-1.0)*x103))+x99+x90);
op[6]=((((-1.0)*x94))+(((-1.0)*x62)));
op[7]=x84;
op[8]=x85;
op[9]=0;
op[10]=(x60+(((-1.0)*x62))+(((-1.0)*x61)));
op[11]=x84;
op[12]=((414.96843037037)+x101+x97+(((-1.0)*x57)));
op[13]=((((-1.0)*x92))+(((-1.0)*x53)));
op[14]=(x63+(((-1.0)*x64)));
op[15]=x88;
op[16]=((414.96843037037)+(((-1.0)*x101))+x97+(((-1.0)*x57)));
op[17]=(x54+(((-1.0)*x52))+(((-1.0)*x53)));
op[18]=x84;
op[19]=((((-1.0)*x100))+x61);
op[20]=0;
op[21]=x85;
op[22]=x84;
op[23]=(x94+(((-1.0)*x62)));
op[24]=(x67+(((-1.0)*x66))+(((-1.0)*x65)));
op[25]=(x70+x68+(((-1.0)*x69)));
op[26]=((((-1.0)*x77))+x76);
op[27]=(x75+x74);
op[28]=(x65+(((-1.0)*x96)));
op[29]=((((-1.0)*x102))+(((-1.0)*x68)));
op[30]=((((-1.0)*x71))+(((-1.0)*x72))+x73);
op[31]=x86;
op[32]=((((-1.0)*x78))+(((-1.0)*x79)));
op[33]=x87;
op[34]=(x71+x95);
op[35]=x80;
op[36]=(x70+(((-1.0)*x69))+(((-1.0)*x68)));
op[37]=(x66+(((-1.0)*x67))+(((-1.0)*x65)));
op[38]=((((-1.0)*x75))+x74);
op[39]=((((-1.0)*x76))+(((-1.0)*x77)));
op[40]=((((-1.0)*x102))+x68);
op[41]=(x65+x96);
op[42]=x86;
op[43]=((((-1.0)*x71))+x95);
op[44]=x87;
op[45]=((((-1.0)*x79))+x78);
op[46]=x80;
op[47]=((((-1.0)*x72))+x73+x71);
op[48]=(r22+(((-1.0)*x92)));
op[49]=((-414.96843037037)+(((-1.0)*x101))+(((-1.0)*x97))+(((-1.0)*x57)));
op[50]=x88;
op[51]=(x64+(((-1.0)*x63)));
op[52]=(x54+r22+(((-1.0)*x52)));
op[53]=((-414.96843037037)+x101+(((-1.0)*x97))+(((-1.0)*x57)));
op[54]=(x60+x89);
op[55]=x81;
op[56]=x83;
op[57]=0;
op[58]=(x89+(((-1.0)*x60)));
op[59]=x81;
op[60]=((((-1.0)*x104))+x98+x91);
op[61]=(x92+r22);
op[62]=((-1.0)*x93);
op[63]=x82;
op[64]=(x103+x91+(((-1.0)*x99)));
op[65]=(x52+r22+(((-1.0)*x54)));
op[66]=x81;
op[67]=(rxp2_2+x60+(((-1.0)*x61)));
op[68]=0;
op[69]=x83;
op[70]=x81;
op[71]=(rxp2_2+(((-1.0)*x94)));
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j4array[16], cj4array[16], sj4array[16], j5array[16], cj5array[16], sj5array[16], j0array[16], cj0array[16], sj0array[16];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ij4 += 3)
{
IkReal htj4 = zeror[ij4+0], htj5 = zeror[ij4+1], htj0 = zeror[ij4+2];
if(isnan(htj4)||isnan(htj5)||isnan(htj0)){
continue;
}
j4array[numsolutions]=((2.0)*(atan(htj4)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j0array[numsolutions]=((2.0)*(atan(htj0)));
if(isinf(htj4)){
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
}
else{
IkReal x105=htj4*htj4;
CheckValue<IkReal> x106=IKPowWithIntegerCheck(((1.0)+x105),-1);
if(!x106.valid){
continue;
}
cj4array[numsolutions]=((x106.value)*(((1.0)+(((-1.0)*x105)))));
CheckValue<IkReal> x107=IKPowWithIntegerCheck(((1.0)+(htj4*htj4)),-1);
if(!x107.valid){
continue;
}
sj4array[numsolutions]=((2.0)*htj4*(x107.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x108=htj5*htj5;
CheckValue<IkReal> x109=IKPowWithIntegerCheck(((1.0)+x108),-1);
if(!x109.valid){
continue;
}
cj5array[numsolutions]=((x109.value)*(((1.0)+(((-1.0)*x108)))));
CheckValue<IkReal> x110=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x110.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x110.value));
}
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x111=htj0*htj0;
CheckValue<IkReal> x112=IKPowWithIntegerCheck(((1.0)+x111),-1);
if(!x112.valid){
continue;
}
cj0array[numsolutions]=((x112.value)*(((1.0)+(((-1.0)*x111)))));
CheckValue<IkReal> x113=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x113.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x113.value));
}
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j4valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj4 = 16;
_nj5 = 1;
_nj0 = 1;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij0[0] = 0; _ij0[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( !j4valid[iij4] ) { continue; }
if( IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij4]-cj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij4]-sj5array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(cj0array[ij4]-cj0array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij4]-sj0array[iij4]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j4valid[iij4]=false; _ij4[1] = iij4; _ij5[1] = 0; _ij0[1] = 0;  break; 
}
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

    j5 = j5array[ij4]; cj5 = cj5array[ij4]; sj5 = sj5array[ij4];

    j0 = j0array[ij4]; cj0 = cj0array[ij4]; sj0 = sj0array[ij4];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[3];
IkReal x114=((1.0)*sj4);
IkReal x115=(cj0*r21);
IkReal x116=((1.0)*cj5);
IkReal x117=(cj0*r20);
IkReal x118=((1.0)*cj4);
IkReal x119=((((-1.0)*r00*sj5*x114))+(((-1.0)*r02*x118))+(((-1.0)*cj5*r01*x114)));
j3eval[0]=x119;
j3eval[1]=IKsign(x119);
j3eval[2]=((IKabs(((((-1.0)*x116*x117))+((sj5*x115)))))+(IKabs(((((-1.0)*cj4*x115*x116))+((cj0*r22*sj4))+(((-1.0)*sj5*x117*x118))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
IkReal x120=((1.0)*sj5);
IkReal x121=(r20*sj0);
IkReal x122=((1.0)*cj5);
IkReal x123=(r21*sj0);
IkReal x124=((((-1.0)*r10*sj4*x120))+(((-1.0)*r11*sj4*x122))+(((-1.0)*cj4*r12)));
j3eval[0]=x124;
j3eval[1]=((IKabs((((r22*sj0*sj4))+(((-1.0)*cj4*x122*x123))+(((-1.0)*cj4*x120*x121)))))+(IKabs((((sj5*x123))+(((-1.0)*x121*x122))))));
j3eval[2]=IKsign(x124);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x125=(((cj4*r22))+((cj5*r21*sj4))+((r20*sj4*sj5)));
j3eval[0]=x125;
j3eval[1]=IKsign(x125);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j0))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x126=((1.0)*r00);
IkReal x127=(((cj4*r22))+((cj5*r21*sj4))+((r20*sj4*sj5)));
j3eval[0]=x127;
j3eval[1]=IKsign(x127);
j3eval[2]=((IKabs((((r01*sj5))+(((-1.0)*cj5*x126)))))+(IKabs(((((-1.0)*cj4*cj5*r01))+((r02*sj4))+(((-1.0)*cj4*sj5*x126))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x128=((1.0)*sj5);
IkReal x129=((1.0)*cj5);
IkReal x130=((((-1.0)*cj4*r02))+(((-1.0)*r01*sj4*x129))+(((-1.0)*r00*sj4*x128)));
j3eval[0]=x130;
j3eval[1]=IKsign(x130);
j3eval[2]=((IKabs(((((-1.0)*cj4*r21*x129))+((r22*sj4))+(((-1.0)*cj4*r20*x128)))))+(IKabs(((((-1.0)*r20*x129))+((r21*sj5))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=1.0;
j0=0;
IkReal x131=cj4*cj4;
IkReal x132=r11*r11;
IkReal x133=cj5*cj5;
IkReal x134=r10*r10;
IkReal x135=r12*r12;
IkReal x136=(cj5*r11);
IkReal x137=((1.0)*cj4);
IkReal x138=((1.0)*x131);
IkReal x139=((2.0)*r10*sj5);
IkReal x140=(cj4*r12*sj4);
IkReal x141=(x133*x134);
IkReal x142=(x132*x133);
IkReal x143=((((-1.0)*x135*x138))+((x131*x142))+(((-1.0)*x138*x141))+((x131*x136*x139))+(((-1.0)*x139*x140))+x141+x135+x132+(((-1.0)*x136*x139))+((x131*x134))+(((-1.0)*x142))+(((-2.0)*x136*x140)));
j3eval[0]=x143;
j3eval[1]=((IKabs(((((-1.0)*x136*x137))+(((-1.0)*r10*sj5*x137))+((r12*sj4)))))+(IKabs((((cj5*r10))+(((-1.0)*r11*sj5))))));
j3eval[2]=IKsign(x143);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x144=cj4*cj4;
IkReal x145=r11*r11;
IkReal x146=cj5*cj5;
IkReal x147=r10*r10;
IkReal x148=r12*r12;
IkReal x149=(cj5*r11);
IkReal x150=((1.0)*sj5);
IkReal x151=((2.0)*r10*sj5);
IkReal x152=(cj4*r12*sj4);
IkReal x153=((1.0)*x144);
IkReal x154=(x146*x147);
IkReal x155=(x145*x146);
CheckValue<IkReal> x156 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*x149))+(((-1.0)*cj4*r10*x150))+((r12*sj4)))),IkReal((((cj5*r10))+(((-1.0)*r11*x150)))),IKFAST_ATAN2_MAGTHRESH);
if(!x156.valid){
continue;
}
CheckValue<IkReal> x157=IKPowWithIntegerCheck(IKsign(((((-1.0)*x153*x154))+((x144*x155))+(((-1.0)*x151*x152))+((x144*x147))+((x144*x149*x151))+x154+x145+x148+(((-2.0)*x149*x152))+(((-1.0)*x155))+(((-1.0)*x148*x153))+(((-1.0)*x149*x151)))),-1);
if(!x157.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x156.value)+(((1.5707963267949)*(x157.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x158=IKsin(j3);
IkReal x159=IKcos(j3);
IkReal x160=(cj4*cj5);
IkReal x161=(r12*sj4);
IkReal x162=(cj5*r10);
IkReal x163=((1.0)*x159);
IkReal x164=(r11*x158);
IkReal x165=((1.0)*x158);
IkReal x166=(sj5*x159);
IkReal x167=(cj4*sj5*x158);
evalcond[0]=(((r20*x167))+((r21*x166))+(((-1.0)*cj5*r20*x163))+((r21*x158*x160))+(((-1.0)*r22*sj4*x165)));
evalcond[1]=(((r01*x166))+((r00*x167))+((r01*x158*x160))+(((-1.0)*r02*sj4*x165))+(((-1.0)*cj5*r00*x163)));
evalcond[2]=((1.0)+(((-1.0)*x161*x165))+(((-1.0)*x162*x163))+((r10*x167))+((x160*x164))+((r11*x166)));
evalcond[3]=((((-1.0)*cj4*r10*sj5*x163))+(((-1.0)*x162*x165))+(((-1.0)*r11*x160*x163))+((sj5*x164))+((x159*x161)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x168=((4.63308)*px);
IkReal x169=((0.81)*pz);
IkReal x170=(cj5*r00);
IkReal x171=(cj5*r20);
IkReal x172=(cj4*r02);
IkReal x173=(cj5*sj4);
IkReal x174=(r01*sj5);
IkReal x175=(cj4*r22);
IkReal x176=(r21*sj5);
IkReal x177=((0.0347481)*x170);
IkReal x178=((0.006075)*x171);
IkReal x179=((0.09)*x174);
IkReal x180=((4.63308)*x172);
IkReal x181=(r00*sj4*sj5);
IkReal x182=(r20*sj4*sj5);
IkReal x183=((4.63308)*r01*x173);
IkReal x184=((4.63308)*x181);
IkReal x185=(x178+x177+x168+x169);
IkReal x186=(x179+x184+x180+x183);
IkReal x187=((((0.81)*x175))+(((0.81)*x182))+(((12.0)*px))+(((0.81)*r21*x173))+(((0.09)*x170)));
IkReal x188=((((1.8434608572)*r01*x173))+(((0.0347481)*x174))+(((0.006075)*x176))+(((1.8434608572)*x181))+(((1.8434608572)*x172)));
j1eval[0]=((1.0)+(((1.48148148148148)*(IKabs(((-1.25)+(((-0.27)*x175))+(((-0.27)*x182))+(((0.03)*x174))+(((-0.03)*x170))+(((1.54436)*x172))+(((1.54436)*x181))+(((-4.0)*px))+(((1.54436)*r01*x173))+(((-0.27)*r21*x173)))))))+(((1.48148148148148)*(IKabs(((-0.4826125)+(((-1.0)*x188))+x185)))))+(((1.48148148148148)*(IKabs(((1.25)+(((-1.0)*x187))+x186)))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((-1.0)*x188))+x185)))))+(((1.48148148148148)*(IKabs(((-1.25)+(((-1.0)*x187))+x186)))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((-0.002025)*x176))+(((0.27)*pz))+(((1.54436)*px))+(((-0.6144869524)*x172))+(((-0.6144869524)*x181))+(((-0.0115827)*x174))+(((-0.6144869524)*r01*x173))+(((0.002025)*x171))+(((0.0115827)*x170))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x189=(cj5*r00);
IkReal x190=(cj5*sj4);
IkReal x191=(r01*sj5);
IkReal x192=(sj4*sj5);
IkReal x193=(cj4*r22);
IkReal x194=(cj4*r02);
IkReal x195=((0.09)*x191);
IkReal x196=((4.63308)*x194);
IkReal x197=((0.03)*x191);
IkReal x198=((1.54436)*x194);
IkReal x199=((4.63308)*r01*x190);
IkReal x200=((4.63308)*r00*x192);
IkReal x201=((1.54436)*r00*x192);
IkReal x202=((1.54436)*r01*x190);
IkReal x203=(x199+x196+x195+x200);
IkReal x204=(x198+x197+x202+x201);
IkReal x205=((((12.0)*px))+(((0.81)*x193))+(((0.81)*r20*x192))+(((0.81)*r21*x190))+(((0.09)*x189)));
IkReal x206=((((0.27)*x193))+(((4.0)*px))+(((0.03)*x189))+(((0.27)*r20*x192))+(((0.27)*r21*x190)));
op[0]=((-1.25)+(((-1.0)*x206))+x204);
op[1]=0;
op[2]=((-1.25)+(((-1.0)*x205))+x203);
op[3]=0;
op[4]=((1.25)+(((-1.0)*x205))+x203);
op[5]=0;
op[6]=((1.25)+(((-1.0)*x206))+x204);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x207=((0.27)*pz);
IkReal x208=((1.54436)*px);
IkReal x209=((4.63308)*px);
IkReal x210=((0.81)*pz);
IkReal x211=(cj5*r20);
IkReal x212=(cj5*r00);
IkReal x213=(r21*sj5);
IkReal x214=(cj4*r02);
IkReal x215=((0.6144869524)*sj4);
IkReal x216=(r00*sj5);
IkReal x217=(cj5*r01);
IkReal x218=((1.8434608572)*sj4);
IkReal x219=(r01*sj5);
IkReal x220=((0.002025)*x211);
IkReal x221=((0.0115827)*x212);
IkReal x222=((0.0347481)*x212);
IkReal x223=((0.006075)*x211);
IkReal x224=(x221+x220+x207+x208);
IkReal x225=(x210+x223+x222+x209);
IkReal x226=(((x216*x218))+(((1.8434608572)*x214))+(((0.0347481)*x219))+((x217*x218))+(((0.006075)*x213)));
IkReal x227=((((0.6144869524)*x214))+((x215*x216))+((x215*x217))+(((0.0115827)*x219))+(((0.002025)*x213)));
j1evalpoly[0]=((-0.4826125)+(((0.16875)*htj1))+(((htj1*htj1)*(((-0.4826125)+x225+(((-1.0)*x226))))))+(((0.3375)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.4826125)+x225+(((-1.0)*x226))))))+x224+(((0.16875)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x227))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.4826125)+x224+(((-1.0)*x227)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x228=((1.0)*cj1);
IkReal x229=(cj4*r22);
IkReal x230=((1.0)*sj1);
IkReal x231=(cj4*r02);
IkReal x232=(r20*sj4*sj5);
IkReal x233=(cj5*r01*sj4);
IkReal x234=(cj5*r21*sj4);
IkReal x235=(r00*sj4*sj5);
if( IKabs(((((-1.0)*x230*x233))+(((-1.0)*x230*x235))+(((-1.0)*x230*x231))+(((-1.0)*x228*x229))+(((-1.0)*x228*x232))+(((-1.0)*x228*x234)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x233))+((cj1*x235))+((cj1*x231))+(((-1.0)*x230*x232))+(((-1.0)*x230*x234))+(((-1.0)*x229*x230)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x230*x233))+(((-1.0)*x230*x235))+(((-1.0)*x230*x231))+(((-1.0)*x228*x229))+(((-1.0)*x228*x232))+(((-1.0)*x228*x234))))+IKsqr((((cj1*x233))+((cj1*x235))+((cj1*x231))+(((-1.0)*x230*x232))+(((-1.0)*x230*x234))+(((-1.0)*x229*x230))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x230*x233))+(((-1.0)*x230*x235))+(((-1.0)*x230*x231))+(((-1.0)*x228*x229))+(((-1.0)*x228*x232))+(((-1.0)*x228*x234))), (((cj1*x233))+((cj1*x235))+((cj1*x231))+(((-1.0)*x230*x232))+(((-1.0)*x230*x234))+(((-1.0)*x229*x230))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x236=IKcos(j2);
IkReal x237=IKsin(j2);
IkReal x238=(cj3*sj4);
IkReal x239=((1.0)*cj5);
IkReal x240=(cj3*cj4);
IkReal x241=(r21*sj5);
IkReal x242=((1.0)*sj5);
IkReal x243=((1.0)*cj4);
IkReal x244=(r01*sj5);
IkReal x245=((0.0075)*cj5);
IkReal x246=(cj1*x236);
IkReal x247=(cj1*x237);
IkReal x248=(sj1*x236);
IkReal x249=(sj1*x237);
IkReal x250=((1.0)*x249);
evalcond[0]=((((-1.0)*r01*sj4*x239))+x246+(((-1.0)*r02*x243))+(((-1.0)*r00*sj4*x242))+(((-1.0)*x250)));
evalcond[1]=((((-1.0)*x248))+(((-1.0)*x247))+(((-1.0)*r21*sj4*x239))+(((-1.0)*r22*x243))+(((-1.0)*r20*sj4*x242)));
evalcond[2]=(((r02*x238))+(((-1.0)*r00*x240*x242))+((sj3*x244))+(((-1.0)*r01*x239*x240))+x247+x248+(((-1.0)*r00*sj3*x239)));
evalcond[3]=((((-1.0)*r20*x240*x242))+((sj3*x241))+(((-1.0)*r21*x239*x240))+x246+(((-1.0)*r20*sj3*x239))+(((-1.0)*x250))+((r22*x238)));
evalcond[4]=((((0.0675)*x246))+(((-0.38609)*x247))+(((-0.38609)*x248))+(((-0.3125)*sj1))+(((0.0075)*x241))+(((-1.0)*pz))+(((-0.0675)*x249))+(((-1.0)*r20*x245)));
evalcond[5]=((((0.0675)*x247))+(((0.0675)*x248))+(((-0.38609)*x249))+(((0.38609)*x246))+(((0.3125)*cj1))+(((0.0075)*x244))+(((-1.0)*px))+(((-1.0)*r00*x245)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x251=((1.0)*sj5);
IkReal x252=((1.0)*cj5);
CheckValue<IkReal> x253=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj4*r02))+(((-1.0)*r01*sj4*x252))+(((-1.0)*r00*sj4*x251)))),-1);
if(!x253.valid){
continue;
}
CheckValue<IkReal> x254 = IKatan2WithCheck(IkReal((((r21*sj5))+(((-1.0)*r20*x252)))),IkReal(((((-1.0)*cj4*r20*x251))+((r22*sj4))+(((-1.0)*cj4*r21*x252)))),IKFAST_ATAN2_MAGTHRESH);
if(!x254.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x253.value)))+(x254.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x255=IKsin(j3);
IkReal x256=IKcos(j3);
IkReal x257=(cj4*cj5);
IkReal x258=(r12*sj4);
IkReal x259=(cj5*r10);
IkReal x260=((1.0)*x256);
IkReal x261=(r11*x255);
IkReal x262=((1.0)*x255);
IkReal x263=(sj5*x256);
IkReal x264=(cj4*sj5*x255);
evalcond[0]=(((r21*x255*x257))+(((-1.0)*r22*sj4*x262))+(((-1.0)*cj5*r20*x260))+((r21*x263))+((r20*x264)));
evalcond[1]=((((-1.0)*r02*sj4*x262))+(((-1.0)*cj5*r00*x260))+((r00*x264))+((r01*x263))+((r01*x255*x257)));
evalcond[2]=((1.0)+(((-1.0)*x258*x262))+(((-1.0)*x259*x260))+((x257*x261))+((r10*x264))+((r11*x263)));
evalcond[3]=((((-1.0)*cj4*r10*sj5*x260))+((sj5*x261))+(((-1.0)*x259*x262))+((x256*x258))+(((-1.0)*r11*x257*x260)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x265=((4.63308)*px);
IkReal x266=((0.81)*pz);
IkReal x267=(cj5*r00);
IkReal x268=(cj5*r20);
IkReal x269=(cj4*r02);
IkReal x270=(cj5*sj4);
IkReal x271=(r01*sj5);
IkReal x272=(cj4*r22);
IkReal x273=(r21*sj5);
IkReal x274=((0.0347481)*x267);
IkReal x275=((0.006075)*x268);
IkReal x276=((0.09)*x271);
IkReal x277=((4.63308)*x269);
IkReal x278=(r00*sj4*sj5);
IkReal x279=(r20*sj4*sj5);
IkReal x280=((4.63308)*r01*x270);
IkReal x281=((4.63308)*x278);
IkReal x282=(x265+x266+x274+x275);
IkReal x283=(x276+x277+x281+x280);
IkReal x284=((((0.81)*x272))+(((0.81)*x279))+(((12.0)*px))+(((0.81)*r21*x270))+(((0.09)*x267)));
IkReal x285=((((1.8434608572)*x269))+(((1.8434608572)*x278))+(((0.0347481)*x271))+(((0.006075)*x273))+(((1.8434608572)*r01*x270)));
j1eval[0]=((1.0)+(((1.48148148148148)*(IKabs(((0.4826125)+(((-0.6144869524)*x278))+(((0.0115827)*x267))+(((-0.6144869524)*x269))+(((0.27)*pz))+(((1.54436)*px))+(((-0.6144869524)*r01*x270))+(((-0.002025)*x273))+(((-0.0115827)*x271))+(((0.002025)*x268)))))))+(((1.48148148148148)*(IKabs(((-0.4826125)+x282+(((-1.0)*x285)))))))+(((1.48148148148148)*(IKabs(((0.4826125)+x282+(((-1.0)*x285)))))))+(((1.48148148148148)*(IKabs(((1.25)+x283+(((-1.0)*x284)))))))+(((1.48148148148148)*(IKabs(((-1.25)+(((1.54436)*r01*x270))+(((-0.27)*r21*x270))+(((0.03)*x271))+(((1.54436)*x278))+(((1.54436)*x269))+(((-0.03)*x267))+(((-4.0)*px))+(((-0.27)*x272))+(((-0.27)*x279)))))))+(((1.48148148148148)*(IKabs(((-1.25)+x283+(((-1.0)*x284))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x286=(cj5*r00);
IkReal x287=(cj5*sj4);
IkReal x288=(r01*sj5);
IkReal x289=(sj4*sj5);
IkReal x290=(cj4*r22);
IkReal x291=(cj4*r02);
IkReal x292=((0.09)*x288);
IkReal x293=((4.63308)*x291);
IkReal x294=((0.03)*x288);
IkReal x295=((1.54436)*x291);
IkReal x296=((4.63308)*r01*x287);
IkReal x297=((4.63308)*r00*x289);
IkReal x298=((1.54436)*r00*x289);
IkReal x299=((1.54436)*r01*x287);
IkReal x300=(x292+x293+x296+x297);
IkReal x301=(x298+x299+x294+x295);
IkReal x302=((((12.0)*px))+(((0.09)*x286))+(((0.81)*x290))+(((0.81)*r21*x287))+(((0.81)*r20*x289)));
IkReal x303=((((0.27)*x290))+(((0.27)*r21*x287))+(((4.0)*px))+(((0.03)*x286))+(((0.27)*r20*x289)));
op[0]=((-1.25)+x301+(((-1.0)*x303)));
op[1]=0;
op[2]=((-1.25)+x300+(((-1.0)*x302)));
op[3]=0;
op[4]=((1.25)+x300+(((-1.0)*x302)));
op[5]=0;
op[6]=((1.25)+x301+(((-1.0)*x303)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x304=((0.27)*pz);
IkReal x305=((1.54436)*px);
IkReal x306=((4.63308)*px);
IkReal x307=((0.81)*pz);
IkReal x308=(cj5*r20);
IkReal x309=(cj5*r00);
IkReal x310=(r21*sj5);
IkReal x311=(cj4*r02);
IkReal x312=((0.6144869524)*sj4);
IkReal x313=(r00*sj5);
IkReal x314=(cj5*r01);
IkReal x315=((1.8434608572)*sj4);
IkReal x316=(r01*sj5);
IkReal x317=((0.002025)*x308);
IkReal x318=((0.0115827)*x309);
IkReal x319=((0.0347481)*x309);
IkReal x320=((0.006075)*x308);
IkReal x321=(x304+x305+x318+x317);
IkReal x322=(x306+x307+x320+x319);
IkReal x323=((((0.006075)*x310))+(((0.0347481)*x316))+((x314*x315))+(((1.8434608572)*x311))+((x313*x315)));
IkReal x324=(((x312*x314))+((x312*x313))+(((0.0115827)*x316))+(((0.6144869524)*x311))+(((0.002025)*x310)));
j1evalpoly[0]=((-0.4826125)+(((htj1*htj1)*(((-0.4826125)+(((-1.0)*x323))+x322))))+(((0.16875)*htj1))+(((0.3375)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x323))+x322))))+(((-1.0)*x324))+x321+(((0.16875)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x324))+x321)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x325=((1.0)*cj1);
IkReal x326=(cj4*r22);
IkReal x327=((1.0)*sj1);
IkReal x328=(cj4*r02);
IkReal x329=(r20*sj4*sj5);
IkReal x330=(cj5*r01*sj4);
IkReal x331=(cj5*r21*sj4);
IkReal x332=(r00*sj4*sj5);
if( IKabs(((((-1.0)*x325*x329))+(((-1.0)*x325*x326))+(((-1.0)*x327*x328))+(((-1.0)*x327*x330))+(((-1.0)*x327*x332))+(((-1.0)*x325*x331)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x328))+((cj1*x332))+((cj1*x330))+(((-1.0)*x326*x327))+(((-1.0)*x327*x329))+(((-1.0)*x327*x331)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x325*x329))+(((-1.0)*x325*x326))+(((-1.0)*x327*x328))+(((-1.0)*x327*x330))+(((-1.0)*x327*x332))+(((-1.0)*x325*x331))))+IKsqr((((cj1*x328))+((cj1*x332))+((cj1*x330))+(((-1.0)*x326*x327))+(((-1.0)*x327*x329))+(((-1.0)*x327*x331))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x325*x329))+(((-1.0)*x325*x326))+(((-1.0)*x327*x328))+(((-1.0)*x327*x330))+(((-1.0)*x327*x332))+(((-1.0)*x325*x331))), (((cj1*x328))+((cj1*x332))+((cj1*x330))+(((-1.0)*x326*x327))+(((-1.0)*x327*x329))+(((-1.0)*x327*x331))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x333=IKcos(j2);
IkReal x334=IKsin(j2);
IkReal x335=(cj3*sj4);
IkReal x336=((1.0)*cj5);
IkReal x337=(cj3*cj4);
IkReal x338=(r21*sj5);
IkReal x339=((1.0)*sj5);
IkReal x340=((1.0)*cj4);
IkReal x341=(r01*sj5);
IkReal x342=((0.0075)*cj5);
IkReal x343=(cj1*x333);
IkReal x344=(cj1*x334);
IkReal x345=(sj1*x333);
IkReal x346=(sj1*x334);
IkReal x347=((1.0)*x346);
evalcond[0]=((((-1.0)*r02*x340))+(((-1.0)*r01*sj4*x336))+(((-1.0)*r00*sj4*x339))+x343+(((-1.0)*x347)));
evalcond[1]=((((-1.0)*r22*x340))+(((-1.0)*r20*sj4*x339))+(((-1.0)*r21*sj4*x336))+(((-1.0)*x345))+(((-1.0)*x344)));
evalcond[2]=((((-1.0)*r00*x337*x339))+(((-1.0)*r00*sj3*x336))+((sj3*x341))+((r02*x335))+(((-1.0)*r01*x336*x337))+x344+x345);
evalcond[3]=(((r22*x335))+(((-1.0)*r20*sj3*x336))+(((-1.0)*r21*x336*x337))+((sj3*x338))+x343+(((-1.0)*r20*x337*x339))+(((-1.0)*x347)));
evalcond[4]=((((-1.0)*r20*x342))+(((-0.0675)*x346))+(((0.0675)*x343))+(((-0.3125)*sj1))+(((-1.0)*pz))+(((0.0075)*x338))+(((-0.38609)*x344))+(((-0.38609)*x345)));
evalcond[5]=((((0.38609)*x343))+(((0.0675)*x345))+(((0.0675)*x344))+(((0.3125)*cj1))+(((0.0075)*x341))+(((-1.0)*px))+(((-0.38609)*x346))+(((-1.0)*r00*x342)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x348=((1.0)*r00);
CheckValue<IkReal> x349 = IKatan2WithCheck(IkReal((((r01*sj5))+(((-1.0)*cj5*x348)))),IkReal(((((-1.0)*cj4*cj5*r01))+((r02*sj4))+(((-1.0)*cj4*sj5*x348)))),IKFAST_ATAN2_MAGTHRESH);
if(!x349.valid){
continue;
}
CheckValue<IkReal> x350=IKPowWithIntegerCheck(IKsign((((cj4*r22))+((cj5*r21*sj4))+((r20*sj4*sj5)))),-1);
if(!x350.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x349.value)+(((1.5707963267949)*(x350.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x351=IKsin(j3);
IkReal x352=IKcos(j3);
IkReal x353=(cj4*cj5);
IkReal x354=(r12*sj4);
IkReal x355=(cj5*r10);
IkReal x356=((1.0)*x352);
IkReal x357=(r11*x351);
IkReal x358=((1.0)*x351);
IkReal x359=(sj5*x352);
IkReal x360=(cj4*sj5*x351);
evalcond[0]=((((-1.0)*cj5*r20*x356))+((r20*x360))+((r21*x359))+((r21*x351*x353))+(((-1.0)*r22*sj4*x358)));
evalcond[1]=(((r01*x351*x353))+((r01*x359))+((r00*x360))+(((-1.0)*r02*sj4*x358))+(((-1.0)*cj5*r00*x356)));
evalcond[2]=((1.0)+((r11*x359))+((x353*x357))+(((-1.0)*x354*x358))+(((-1.0)*x355*x356))+((r10*x360)));
evalcond[3]=((((-1.0)*cj4*r10*sj5*x356))+((sj5*x357))+((x352*x354))+(((-1.0)*r11*x353*x356))+(((-1.0)*x355*x358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=1.0;
j0=0;
IkReal x361=((4.63308)*px);
IkReal x362=((0.81)*pz);
IkReal x363=(cj5*r00);
IkReal x364=(cj5*r20);
IkReal x365=(cj4*r02);
IkReal x366=(cj5*sj4);
IkReal x367=(r01*sj5);
IkReal x368=(cj4*r22);
IkReal x369=(r21*sj5);
IkReal x370=((0.0347481)*x363);
IkReal x371=((0.006075)*x364);
IkReal x372=((0.09)*x367);
IkReal x373=((4.63308)*x365);
IkReal x374=(r00*sj4*sj5);
IkReal x375=(r20*sj4*sj5);
IkReal x376=((4.63308)*r01*x366);
IkReal x377=((4.63308)*x374);
IkReal x378=(x371+x370+x361+x362);
IkReal x379=(x377+x376+x373+x372);
IkReal x380=((((12.0)*px))+(((0.81)*x368))+(((0.81)*x375))+(((0.09)*x363))+(((0.81)*r21*x366)));
IkReal x381=((((0.0347481)*x367))+(((1.8434608572)*x374))+(((1.8434608572)*x365))+(((0.006075)*x369))+(((1.8434608572)*r01*x366)));
j1eval[0]=((1.0)+(((1.48148148148148)*(IKabs(((-0.4826125)+x378+(((-1.0)*x381)))))))+(((1.48148148148148)*(IKabs(((-1.25)+x379+(((-1.0)*x380)))))))+(((1.48148148148148)*(IKabs(((-1.25)+(((1.54436)*x374))+(((-0.03)*x363))+(((1.54436)*r01*x366))+(((-0.27)*x368))+(((-0.27)*x375))+(((-0.27)*r21*x366))+(((0.03)*x367))+(((-4.0)*px))+(((1.54436)*x365)))))))+(((1.48148148148148)*(IKabs(((0.4826125)+x378+(((-1.0)*x381)))))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((-0.6144869524)*x365))+(((0.27)*pz))+(((-0.6144869524)*x374))+(((1.54436)*px))+(((0.0115827)*x363))+(((-0.0115827)*x367))+(((0.002025)*x364))+(((-0.002025)*x369))+(((-0.6144869524)*r01*x366)))))))+(((1.48148148148148)*(IKabs(((1.25)+x379+(((-1.0)*x380))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x382=(cj5*r00);
IkReal x383=(cj5*sj4);
IkReal x384=(r01*sj5);
IkReal x385=(sj4*sj5);
IkReal x386=(cj4*r22);
IkReal x387=(cj4*r02);
IkReal x388=((0.09)*x384);
IkReal x389=((4.63308)*x387);
IkReal x390=((0.03)*x384);
IkReal x391=((1.54436)*x387);
IkReal x392=((4.63308)*r01*x383);
IkReal x393=((4.63308)*r00*x385);
IkReal x394=((1.54436)*r00*x385);
IkReal x395=((1.54436)*r01*x383);
IkReal x396=(x388+x389+x393+x392);
IkReal x397=(x395+x394+x391+x390);
IkReal x398=((((12.0)*px))+(((0.81)*x386))+(((0.81)*r21*x383))+(((0.09)*x382))+(((0.81)*r20*x385)));
IkReal x399=((((0.27)*r20*x385))+(((4.0)*px))+(((0.27)*r21*x383))+(((0.27)*x386))+(((0.03)*x382)));
op[0]=((-1.25)+(((-1.0)*x399))+x397);
op[1]=0;
op[2]=((-1.25)+(((-1.0)*x398))+x396);
op[3]=0;
op[4]=((1.25)+(((-1.0)*x398))+x396);
op[5]=0;
op[6]=((1.25)+(((-1.0)*x399))+x397);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x400=((0.27)*pz);
IkReal x401=((1.54436)*px);
IkReal x402=((4.63308)*px);
IkReal x403=((0.81)*pz);
IkReal x404=(cj5*r20);
IkReal x405=(cj5*r00);
IkReal x406=(r21*sj5);
IkReal x407=(cj4*r02);
IkReal x408=((0.6144869524)*sj4);
IkReal x409=(r00*sj5);
IkReal x410=(cj5*r01);
IkReal x411=((1.8434608572)*sj4);
IkReal x412=(r01*sj5);
IkReal x413=((0.002025)*x404);
IkReal x414=((0.0115827)*x405);
IkReal x415=((0.0347481)*x405);
IkReal x416=((0.006075)*x404);
IkReal x417=(x401+x400+x413+x414);
IkReal x418=(x403+x402+x416+x415);
IkReal x419=((((1.8434608572)*x407))+(((0.0347481)*x412))+(((0.006075)*x406))+((x410*x411))+((x409*x411)));
IkReal x420=((((0.6144869524)*x407))+((x408*x410))+((x408*x409))+(((0.0115827)*x412))+(((0.002025)*x406)));
j1evalpoly[0]=((-0.4826125)+(((htj1*htj1*htj1*htj1)*(((0.4826125)+x418+(((-1.0)*x419))))))+(((0.16875)*htj1))+(((-1.0)*x420))+(((0.3375)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x420))+x417))))+(((0.16875)*(htj1*htj1*htj1*htj1*htj1)))+x417+(((htj1*htj1)*(((-0.4826125)+x418+(((-1.0)*x419)))))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x421=((1.0)*cj1);
IkReal x422=(cj4*r22);
IkReal x423=((1.0)*sj1);
IkReal x424=(cj4*r02);
IkReal x425=(r20*sj4*sj5);
IkReal x426=(cj5*r01*sj4);
IkReal x427=(cj5*r21*sj4);
IkReal x428=(r00*sj4*sj5);
if( IKabs(((((-1.0)*x421*x425))+(((-1.0)*x421*x427))+(((-1.0)*x421*x422))+(((-1.0)*x423*x428))+(((-1.0)*x423*x426))+(((-1.0)*x423*x424)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x422*x423))+(((-1.0)*x423*x427))+(((-1.0)*x423*x425))+((cj1*x428))+((cj1*x426))+((cj1*x424)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x421*x425))+(((-1.0)*x421*x427))+(((-1.0)*x421*x422))+(((-1.0)*x423*x428))+(((-1.0)*x423*x426))+(((-1.0)*x423*x424))))+IKsqr(((((-1.0)*x422*x423))+(((-1.0)*x423*x427))+(((-1.0)*x423*x425))+((cj1*x428))+((cj1*x426))+((cj1*x424))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x421*x425))+(((-1.0)*x421*x427))+(((-1.0)*x421*x422))+(((-1.0)*x423*x428))+(((-1.0)*x423*x426))+(((-1.0)*x423*x424))), ((((-1.0)*x422*x423))+(((-1.0)*x423*x427))+(((-1.0)*x423*x425))+((cj1*x428))+((cj1*x426))+((cj1*x424))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x429=IKcos(j2);
IkReal x430=IKsin(j2);
IkReal x431=(cj3*sj4);
IkReal x432=((1.0)*cj5);
IkReal x433=(cj3*cj4);
IkReal x434=(r21*sj5);
IkReal x435=((1.0)*sj5);
IkReal x436=((1.0)*cj4);
IkReal x437=(r01*sj5);
IkReal x438=((0.0075)*cj5);
IkReal x439=(cj1*x429);
IkReal x440=(cj1*x430);
IkReal x441=(sj1*x429);
IkReal x442=(sj1*x430);
IkReal x443=((1.0)*x442);
evalcond[0]=((((-1.0)*x443))+(((-1.0)*r00*sj4*x435))+(((-1.0)*r01*sj4*x432))+x439+(((-1.0)*r02*x436)));
evalcond[1]=((((-1.0)*r21*sj4*x432))+(((-1.0)*r20*sj4*x435))+(((-1.0)*x441))+(((-1.0)*x440))+(((-1.0)*r22*x436)));
evalcond[2]=((((-1.0)*r01*x432*x433))+((r02*x431))+(((-1.0)*r00*x433*x435))+(((-1.0)*r00*sj3*x432))+x441+x440+((sj3*x437)));
evalcond[3]=((((-1.0)*x443))+(((-1.0)*r20*x433*x435))+((r22*x431))+x439+((sj3*x434))+(((-1.0)*r20*sj3*x432))+(((-1.0)*r21*x432*x433)));
evalcond[4]=((((-0.3125)*sj1))+(((-0.38609)*x441))+(((-0.38609)*x440))+(((-1.0)*pz))+(((-1.0)*r20*x438))+(((0.0675)*x439))+(((-0.0675)*x442))+(((0.0075)*x434)));
evalcond[5]=((((0.38609)*x439))+(((0.3125)*cj1))+(((-0.38609)*x442))+(((-1.0)*px))+(((0.0675)*x441))+(((0.0675)*x440))+(((-1.0)*r00*x438))+(((0.0075)*x437)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x444=((1.0)*r20);
IkReal x445=(((r00*sj4*sj5))+((cj5*r01*sj4))+((cj4*r02)));
j3eval[0]=x445;
j3eval[1]=IKsign(x445);
j3eval[2]=((IKabs((((r21*sj5))+(((-1.0)*cj5*x444)))))+(IKabs((((r22*sj4))+(((-1.0)*cj4*cj5*r21))+(((-1.0)*cj4*sj5*x444))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x446=((1.0)*sj4);
IkReal x447=((1.0)*cj4);
IkReal x448=((((-1.0)*cj5*r21*x446))+(((-1.0)*r22*x447))+(((-1.0)*r20*sj5*x446)));
j3eval[0]=x448;
j3eval[1]=((IKabs(((((-1.0)*cj5*r01*x447))+(((-1.0)*r00*sj5*x447))+((r02*sj4)))))+(IKabs((((r01*sj5))+(((-1.0)*cj5*r00))))));
j3eval[2]=IKsign(x448);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x449=cj4*cj4;
IkReal x450=cj5*cj5;
IkReal x451=r10*r10;
IkReal x452=r11*r11;
IkReal x453=r12*r12;
IkReal x454=(cj5*r10);
IkReal x455=((1.0)*x449);
IkReal x456=(cj4*r10*sj5);
IkReal x457=((2.0)*r12*sj4);
IkReal x458=((2.0)*r11*sj5);
IkReal x459=(cj4*cj5*r11);
IkReal x460=(x450*x452);
IkReal x461=(x450*x451);
IkReal x462=(((x454*x458))+(((-1.0)*x449*x454*x458))+(((-1.0)*x452))+(((-1.0)*x453))+(((-1.0)*x461))+x460+((x449*x453))+(((-1.0)*x455*x460))+((x449*x461))+(((-1.0)*x451*x455))+((x456*x457))+((x457*x459)));
j3eval[0]=x462;
j3eval[1]=IKsign(x462);
j3eval[2]=((IKabs((x454+(((-1.0)*r11*sj5)))))+(IKabs(((((-1.0)*x459))+(((-1.0)*x456))+((r12*sj4))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x463=cj4*cj4;
IkReal x464=cj5*cj5;
IkReal x465=r10*r10;
IkReal x466=r11*r11;
IkReal x467=r12*r12;
IkReal x468=(cj5*r11);
IkReal x469=(r10*sj5);
IkReal x470=((1.0)*cj4);
IkReal x471=((1.0)*x463);
IkReal x472=(x464*x466);
IkReal x473=((2.0)*cj4*r12*sj4);
IkReal x474=(x464*x465);
CheckValue<IkReal> x475 = IKatan2WithCheck(IkReal(((((-1.0)*x468*x470))+(((-1.0)*x469*x470))+((r12*sj4)))),IkReal((((cj5*r10))+(((-1.0)*r11*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x475.valid){
continue;
}
CheckValue<IkReal> x476=IKPowWithIntegerCheck(IKsign(((((2.0)*x468*x469))+((x469*x473))+((x463*x474))+((x463*x467))+(((-1.0)*x467))+(((-1.0)*x466))+(((-1.0)*x474))+x472+(((-1.0)*x471*x472))+(((-2.0)*x463*x468*x469))+(((-1.0)*x465*x471))+((x468*x473)))),-1);
if(!x476.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x475.value)+(((1.5707963267949)*(x476.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x477=IKsin(j3);
IkReal x478=IKcos(j3);
IkReal x479=(cj4*cj5);
IkReal x480=(r12*sj4);
IkReal x481=(cj5*r10);
IkReal x482=((1.0)*x478);
IkReal x483=(r11*x477);
IkReal x484=((1.0)*x477);
IkReal x485=(sj5*x478);
IkReal x486=(cj4*sj5*x477);
evalcond[0]=(((r20*x486))+(((-1.0)*r22*sj4*x484))+(((-1.0)*cj5*r20*x482))+((r21*x485))+((r21*x477*x479)));
evalcond[1]=((((-1.0)*cj5*r00*x482))+(((-1.0)*r02*sj4*x484))+((r01*x485))+((r00*x486))+((r01*x477*x479)));
evalcond[2]=((-1.0)+(((-1.0)*x481*x482))+((r10*x486))+((r11*x485))+(((-1.0)*x480*x484))+((x479*x483)));
evalcond[3]=((((-1.0)*x481*x484))+((x478*x480))+((sj5*x483))+(((-1.0)*r11*x479*x482))+(((-1.0)*cj4*r10*sj5*x482)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x487=((12.0)*px);
IkReal x488=(cj5*r00);
IkReal x489=(r21*sj5);
IkReal x490=((0.81)*cj3);
IkReal x491=((1.54436)*cj4);
IkReal x492=(r02*sj4);
IkReal x493=((0.27)*cj3);
IkReal x494=((0.27)*sj3);
IkReal x495=(cj5*r01);
IkReal x496=(r01*sj5);
IkReal x497=((4.63308)*sj4);
IkReal x498=(cj5*r21);
IkReal x499=((0.81)*sj3);
IkReal x500=((4.63308)*cj4);
IkReal x501=(cj5*r20);
IkReal x502=(cj4*r02);
IkReal x503=((1.54436)*sj4);
IkReal x504=((0.09)*x488);
IkReal x505=(cj4*r00*sj5);
IkReal x506=(r20*sj4*sj5);
IkReal x507=(r00*sj4*sj5);
IkReal x508=(x490*x492);
IkReal x509=(x496*x499);
IkReal x510=(x487+x508+x509+x504);
IkReal x511=(((x488*x499))+((x495*x497))+((x490*x505))+(((0.09)*x496))+((r00*sj5*x497))+((cj4*x490*x495))+((r02*x500)));
j1eval[0]=((5.0)+(((0.5)*(IKabs(((-1.25)+x510+(((-1.0)*x511)))))))+(IKabs(((((12.0)*pz))+(((0.81)*sj4*x495))+(((-1.0)*x497*x498))+(((0.81)*x502))+(((0.81)*x507))+(((-1.0)*r22*x500))+(((-0.09)*x489))+(((-1.0)*r20*sj5*x497))+(((0.09)*x501)))))+(((0.5)*(IKabs(((1.25)+x510+(((-1.0)*x511)))))))+(((0.5)*(IKabs(((-1.25)+(((-1.0)*x488*x494))+(((4.0)*px))+(((-1.0)*r02*x491))+((x494*x496))+(((-1.0)*x495*x503))+(((-1.0)*r00*sj5*x503))+(((0.03)*x488))+(((-1.0)*x493*x505))+(((-0.03)*x496))+(((-1.0)*cj4*x493*x495))+((x492*x493)))))))+(((0.5)*(IKabs(((((0.03)*x501))+(((4.0)*pz))+(((-1.0)*r20*sj5*x503))+(((-1.0)*r22*x491))+(((0.27)*x502))+(((0.27)*x507))+(((0.27)*sj4*x495))+(((-1.0)*x498*x503))+(((-0.03)*x489))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x512=(cj5*sj4);
IkReal x513=(cj4*r22);
IkReal x514=(r21*sj5);
IkReal x515=(cj4*r02);
IkReal x516=(cj5*r20);
IkReal x517=(r20*sj4*sj5);
IkReal x518=(r00*sj4*sj5);
IkReal x519=((((-4.63308)*x513))+(((-4.63308)*x517))+(((12.0)*pz))+(((0.09)*x516))+(((-4.63308)*r21*x512))+(((0.81)*r01*x512))+(((-0.09)*x514))+(((0.81)*x515))+(((0.81)*x518)));
IkReal x520=((((-1.54436)*r21*x512))+(((4.0)*pz))+(((0.27)*x518))+(((0.27)*x515))+(((-1.54436)*x517))+(((-1.54436)*x513))+(((0.27)*r01*x512))+(((0.03)*x516))+(((-0.03)*x514)));
op[0]=x520;
op[1]=2.5;
op[2]=x519;
op[3]=5.0;
op[4]=x519;
op[5]=2.5;
op[6]=x520;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x521=((4.0)*px);
IkReal x522=((12.0)*px);
IkReal x523=(cj5*r00);
IkReal x524=((0.81)*cj3);
IkReal x525=(r02*sj4);
IkReal x526=((0.27)*cj3);
IkReal x527=(cj4*r02);
IkReal x528=((0.27)*sj3);
IkReal x529=(cj5*r01);
IkReal x530=(r01*sj5);
IkReal x531=((0.81)*sj3);
IkReal x532=((0.03)*x523);
IkReal x533=((0.09)*x523);
IkReal x534=(cj4*r00*sj5);
IkReal x535=(r00*sj4*sj5);
IkReal x536=(x525*x526);
IkReal x537=(x528*x530);
IkReal x538=(x524*x525);
IkReal x539=(x530*x531);
IkReal x540=(x533+x539+x538+x522);
IkReal x541=(x532+x537+x536+x521);
IkReal x542=(((cj4*x524*x529))+(((0.09)*x530))+(((4.63308)*sj4*x529))+((x524*x534))+(((4.63308)*x535))+(((4.63308)*x527))+((x523*x531)));
IkReal x543=(((cj4*x526*x529))+(((0.03)*x530))+((x526*x534))+(((1.54436)*sj4*x529))+(((1.54436)*x535))+(((1.54436)*x527))+((x523*x528)));
j1evalpoly[0]=((1.25)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.25)+(((-1.0)*x543))+x541))))+(((-1.0)*x543))+(((htj1*htj1)*(((1.25)+(((-1.0)*x542))+x540))))+x541+(((htj1*htj1*htj1*htj1)*(((-1.25)+(((-1.0)*x542))+x540)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x544=((1.0)*cj1);
IkReal x545=(cj4*r22);
IkReal x546=(cj4*r02);
IkReal x547=((1.0)*sj1);
IkReal x548=(cj5*sj4);
IkReal x549=(r20*sj4*sj5);
IkReal x550=(r00*sj4*sj5);
if( IKabs((((sj1*x550))+(((-1.0)*x544*x545))+(((-1.0)*x544*x549))+((sj1*x546))+(((-1.0)*r21*x544*x548))+((r01*sj1*x548)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x544*x546))+(((-1.0)*x545*x547))+(((-1.0)*x544*x550))+(((-1.0)*r01*x544*x548))+(((-1.0)*x547*x549))+(((-1.0)*r21*x547*x548)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x550))+(((-1.0)*x544*x545))+(((-1.0)*x544*x549))+((sj1*x546))+(((-1.0)*r21*x544*x548))+((r01*sj1*x548))))+IKsqr(((((-1.0)*x544*x546))+(((-1.0)*x545*x547))+(((-1.0)*x544*x550))+(((-1.0)*r01*x544*x548))+(((-1.0)*x547*x549))+(((-1.0)*r21*x547*x548))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((sj1*x550))+(((-1.0)*x544*x545))+(((-1.0)*x544*x549))+((sj1*x546))+(((-1.0)*r21*x544*x548))+((r01*sj1*x548))), ((((-1.0)*x544*x546))+(((-1.0)*x545*x547))+(((-1.0)*x544*x550))+(((-1.0)*r01*x544*x548))+(((-1.0)*x547*x549))+(((-1.0)*r21*x547*x548))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x551=IKcos(j2);
IkReal x552=IKsin(j2);
IkReal x553=(cj3*sj4);
IkReal x554=((1.0)*cj5);
IkReal x555=(cj3*cj4);
IkReal x556=(r21*sj5);
IkReal x557=((1.0)*sj5);
IkReal x558=((1.0)*cj4);
IkReal x559=(r01*sj5);
IkReal x560=((0.0075)*cj5);
IkReal x561=(cj1*x551);
IkReal x562=(cj1*x552);
IkReal x563=(sj1*x551);
IkReal x564=(sj1*x552);
IkReal x565=((1.0)*x563);
IkReal x566=((1.0)*x562);
IkReal x567=(x566+x565);
evalcond[0]=((((-1.0)*r01*sj4*x554))+(((-1.0)*r02*x558))+(((-1.0)*r00*sj4*x557))+x564+(((-1.0)*x561)));
evalcond[1]=((((-1.0)*r20*sj4*x557))+(((-1.0)*r22*x558))+(((-1.0)*r21*sj4*x554))+(((-1.0)*x567)));
evalcond[2]=((((-1.0)*r21*x554*x555))+((sj3*x556))+(((-1.0)*r20*sj3*x554))+x561+(((-1.0)*x564))+((r22*x553))+(((-1.0)*r20*x555*x557)));
evalcond[3]=(((r02*x553))+(((-1.0)*r00*x555*x557))+(((-1.0)*r00*sj3*x554))+(((-1.0)*r01*x554*x555))+((sj3*x559))+(((-1.0)*x567)));
evalcond[4]=((((-0.38609)*x562))+(((-0.38609)*x563))+(((-0.3125)*sj1))+(((0.0075)*x556))+(((-1.0)*pz))+(((0.0675)*x561))+(((-0.0675)*x564))+(((-1.0)*r20*x560)));
evalcond[5]=((((-0.38609)*x561))+(((0.0075)*x559))+(((0.38609)*x564))+(((-1.0)*px))+(((-0.0675)*x563))+(((-0.0675)*x562))+(((-1.0)*r00*x560))+(((-0.3125)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x568=((1.0)*sj4);
IkReal x569=((1.0)*cj4);
CheckValue<IkReal> x570=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj5*r21*x568))+(((-1.0)*r22*x569))+(((-1.0)*r20*sj5*x568)))),-1);
if(!x570.valid){
continue;
}
CheckValue<IkReal> x571 = IKatan2WithCheck(IkReal((((r01*sj5))+(((-1.0)*cj5*r00)))),IkReal((((r02*sj4))+(((-1.0)*cj5*r01*x569))+(((-1.0)*r00*sj5*x569)))),IKFAST_ATAN2_MAGTHRESH);
if(!x571.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x570.value)))+(x571.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x572=IKsin(j3);
IkReal x573=IKcos(j3);
IkReal x574=(cj4*cj5);
IkReal x575=(r12*sj4);
IkReal x576=(cj5*r10);
IkReal x577=((1.0)*x573);
IkReal x578=(r11*x572);
IkReal x579=((1.0)*x572);
IkReal x580=(sj5*x573);
IkReal x581=(cj4*sj5*x572);
evalcond[0]=(((r20*x581))+(((-1.0)*r22*sj4*x579))+((r21*x572*x574))+((r21*x580))+(((-1.0)*cj5*r20*x577)));
evalcond[1]=((((-1.0)*r02*sj4*x579))+(((-1.0)*cj5*r00*x577))+((r01*x580))+((r00*x581))+((r01*x572*x574)));
evalcond[2]=((-1.0)+((r11*x580))+((r10*x581))+((x574*x578))+(((-1.0)*x576*x577))+(((-1.0)*x575*x579)));
evalcond[3]=(((x573*x575))+(((-1.0)*x576*x579))+((sj5*x578))+(((-1.0)*r11*x574*x577))+(((-1.0)*cj4*r10*sj5*x577)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x582=((12.0)*px);
IkReal x583=(cj5*r00);
IkReal x584=(r21*sj5);
IkReal x585=((0.81)*cj3);
IkReal x586=((1.54436)*cj4);
IkReal x587=(r02*sj4);
IkReal x588=((0.27)*cj3);
IkReal x589=((0.27)*sj3);
IkReal x590=(cj5*r01);
IkReal x591=(r01*sj5);
IkReal x592=((4.63308)*sj4);
IkReal x593=(cj5*r21);
IkReal x594=((0.81)*sj3);
IkReal x595=((4.63308)*cj4);
IkReal x596=(cj5*r20);
IkReal x597=(cj4*r02);
IkReal x598=((1.54436)*sj4);
IkReal x599=((0.09)*x583);
IkReal x600=(cj4*r00*sj5);
IkReal x601=(r20*sj4*sj5);
IkReal x602=(r00*sj4*sj5);
IkReal x603=(x585*x587);
IkReal x604=(x591*x594);
IkReal x605=(x582+x599+x603+x604);
IkReal x606=(((cj4*x585*x590))+(((0.09)*x591))+((x585*x600))+((r02*x595))+((x583*x594))+((x590*x592))+((r00*sj5*x592)));
j1eval[0]=((5.0)+(((0.5)*(IKabs(((((0.27)*x602))+(((-1.0)*r22*x586))+(((0.03)*x596))+(((4.0)*pz))+(((0.27)*x597))+(((-0.03)*x584))+(((-1.0)*x593*x598))+(((0.27)*sj4*x590))+(((-1.0)*r20*sj5*x598)))))))+(IKabs(((((0.09)*x596))+(((0.81)*x597))+(((12.0)*pz))+(((0.81)*sj4*x590))+(((-1.0)*x592*x593))+(((-0.09)*x584))+(((-1.0)*r22*x595))+(((-1.0)*r20*sj5*x592))+(((0.81)*x602)))))+(((0.5)*(IKabs(((-1.25)+x605+(((-1.0)*x606)))))))+(((0.5)*(IKabs(((-1.25)+(((-1.0)*r00*sj5*x598))+(((-1.0)*cj4*x588*x590))+(((-0.03)*x591))+(((-1.0)*r02*x586))+(((4.0)*px))+((x587*x588))+(((-1.0)*x583*x589))+(((-1.0)*x590*x598))+(((0.03)*x583))+(((-1.0)*x588*x600))+((x589*x591)))))))+(((0.5)*(IKabs(((1.25)+x605+(((-1.0)*x606))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x607=(cj5*sj4);
IkReal x608=(cj4*r22);
IkReal x609=(r21*sj5);
IkReal x610=(cj4*r02);
IkReal x611=(cj5*r20);
IkReal x612=(r20*sj4*sj5);
IkReal x613=(r00*sj4*sj5);
IkReal x614=((((12.0)*pz))+(((0.81)*x613))+(((0.81)*x610))+(((0.81)*r01*x607))+(((0.09)*x611))+(((-4.63308)*r21*x607))+(((-0.09)*x609))+(((-4.63308)*x608))+(((-4.63308)*x612)));
IkReal x615=((((4.0)*pz))+(((-0.03)*x609))+(((0.27)*r01*x607))+(((0.03)*x611))+(((-1.54436)*x612))+(((-1.54436)*x608))+(((0.27)*x610))+(((0.27)*x613))+(((-1.54436)*r21*x607)));
op[0]=x615;
op[1]=2.5;
op[2]=x614;
op[3]=5.0;
op[4]=x614;
op[5]=2.5;
op[6]=x615;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x616=((4.0)*px);
IkReal x617=((12.0)*px);
IkReal x618=(cj5*r00);
IkReal x619=((0.81)*cj3);
IkReal x620=(r02*sj4);
IkReal x621=((0.27)*cj3);
IkReal x622=(cj4*r02);
IkReal x623=((0.27)*sj3);
IkReal x624=(cj5*r01);
IkReal x625=(r01*sj5);
IkReal x626=((0.81)*sj3);
IkReal x627=((0.03)*x618);
IkReal x628=((0.09)*x618);
IkReal x629=(cj4*r00*sj5);
IkReal x630=(r00*sj4*sj5);
IkReal x631=(x620*x621);
IkReal x632=(x623*x625);
IkReal x633=(x619*x620);
IkReal x634=(x625*x626);
IkReal x635=(x617+x628+x634+x633);
IkReal x636=(x616+x627+x632+x631);
IkReal x637=((((4.63308)*sj4*x624))+((x619*x629))+((x618*x626))+(((4.63308)*x622))+(((4.63308)*x630))+(((0.09)*x625))+((cj4*x619*x624)));
IkReal x638=((((0.03)*x625))+((cj4*x621*x624))+((x618*x623))+(((1.54436)*sj4*x624))+(((1.54436)*x622))+(((1.54436)*x630))+((x621*x629)));
j1evalpoly[0]=((1.25)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.25)+(((-1.0)*x638))+x636))))+(((-1.0)*x638))+x636+(((htj1*htj1*htj1*htj1)*(((-1.25)+(((-1.0)*x637))+x635))))+(((htj1*htj1)*(((1.25)+(((-1.0)*x637))+x635)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x639=((1.0)*cj1);
IkReal x640=(cj4*r22);
IkReal x641=(cj4*r02);
IkReal x642=((1.0)*sj1);
IkReal x643=(cj5*sj4);
IkReal x644=(r20*sj4*sj5);
IkReal x645=(r00*sj4*sj5);
if( IKabs((((sj1*x641))+((sj1*x645))+(((-1.0)*r21*x639*x643))+(((-1.0)*x639*x644))+(((-1.0)*x639*x640))+((r01*sj1*x643)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x642*x644))+(((-1.0)*x640*x642))+(((-1.0)*x639*x645))+(((-1.0)*x639*x641))+(((-1.0)*r01*x639*x643))+(((-1.0)*r21*x642*x643)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x641))+((sj1*x645))+(((-1.0)*r21*x639*x643))+(((-1.0)*x639*x644))+(((-1.0)*x639*x640))+((r01*sj1*x643))))+IKsqr(((((-1.0)*x642*x644))+(((-1.0)*x640*x642))+(((-1.0)*x639*x645))+(((-1.0)*x639*x641))+(((-1.0)*r01*x639*x643))+(((-1.0)*r21*x642*x643))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((sj1*x641))+((sj1*x645))+(((-1.0)*r21*x639*x643))+(((-1.0)*x639*x644))+(((-1.0)*x639*x640))+((r01*sj1*x643))), ((((-1.0)*x642*x644))+(((-1.0)*x640*x642))+(((-1.0)*x639*x645))+(((-1.0)*x639*x641))+(((-1.0)*r01*x639*x643))+(((-1.0)*r21*x642*x643))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x646=IKcos(j2);
IkReal x647=IKsin(j2);
IkReal x648=(cj3*sj4);
IkReal x649=((1.0)*cj5);
IkReal x650=(cj3*cj4);
IkReal x651=(r21*sj5);
IkReal x652=((1.0)*sj5);
IkReal x653=((1.0)*cj4);
IkReal x654=(r01*sj5);
IkReal x655=((0.0075)*cj5);
IkReal x656=(cj1*x646);
IkReal x657=(cj1*x647);
IkReal x658=(sj1*x646);
IkReal x659=(sj1*x647);
IkReal x660=((1.0)*x658);
IkReal x661=((1.0)*x657);
IkReal x662=(x661+x660);
evalcond[0]=((((-1.0)*x656))+(((-1.0)*r00*sj4*x652))+(((-1.0)*r01*sj4*x649))+(((-1.0)*r02*x653))+x659);
evalcond[1]=((((-1.0)*r20*sj4*x652))+(((-1.0)*r22*x653))+(((-1.0)*r21*sj4*x649))+(((-1.0)*x662)));
evalcond[2]=((((-1.0)*r21*x649*x650))+(((-1.0)*x659))+(((-1.0)*r20*x650*x652))+((sj3*x651))+x656+((r22*x648))+(((-1.0)*r20*sj3*x649)));
evalcond[3]=((((-1.0)*r00*x650*x652))+((r02*x648))+((sj3*x654))+(((-1.0)*x662))+(((-1.0)*r00*sj3*x649))+(((-1.0)*r01*x649*x650)));
evalcond[4]=((((-0.3125)*sj1))+(((0.0675)*x656))+(((-0.38609)*x658))+(((-0.38609)*x657))+(((-1.0)*pz))+(((0.0075)*x651))+(((-0.0675)*x659))+(((-1.0)*r20*x655)));
evalcond[5]=((((-0.38609)*x656))+(((-1.0)*r00*x655))+(((-1.0)*px))+(((0.0075)*x654))+(((-0.0675)*x658))+(((-0.0675)*x657))+(((-0.3125)*cj1))+(((0.38609)*x659)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x663=((1.0)*r20);
CheckValue<IkReal> x664 = IKatan2WithCheck(IkReal((((r21*sj5))+(((-1.0)*cj5*x663)))),IkReal((((r22*sj4))+(((-1.0)*cj4*cj5*r21))+(((-1.0)*cj4*sj5*x663)))),IKFAST_ATAN2_MAGTHRESH);
if(!x664.valid){
continue;
}
CheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign((((r00*sj4*sj5))+((cj5*r01*sj4))+((cj4*r02)))),-1);
if(!x665.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x664.value)+(((1.5707963267949)*(x665.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x666=IKsin(j3);
IkReal x667=IKcos(j3);
IkReal x668=(cj4*cj5);
IkReal x669=(r12*sj4);
IkReal x670=(cj5*r10);
IkReal x671=((1.0)*x667);
IkReal x672=(r11*x666);
IkReal x673=((1.0)*x666);
IkReal x674=(sj5*x667);
IkReal x675=(cj4*sj5*x666);
evalcond[0]=((((-1.0)*cj5*r20*x671))+(((-1.0)*r22*sj4*x673))+((r21*x674))+((r21*x666*x668))+((r20*x675)));
evalcond[1]=(((r01*x674))+((r00*x675))+(((-1.0)*cj5*r00*x671))+((r01*x666*x668))+(((-1.0)*r02*sj4*x673)));
evalcond[2]=((-1.0)+((r10*x675))+((r11*x674))+(((-1.0)*x670*x671))+((x668*x672))+(((-1.0)*x669*x673)));
evalcond[3]=(((sj5*x672))+((x667*x669))+(((-1.0)*cj4*r10*sj5*x671))+(((-1.0)*x670*x673))+(((-1.0)*r11*x668*x671)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=0;
cj0=-1.0;
j0=3.14159265358979;
IkReal x676=((12.0)*px);
IkReal x677=(cj5*r00);
IkReal x678=(r21*sj5);
IkReal x679=((0.81)*cj3);
IkReal x680=((1.54436)*cj4);
IkReal x681=(r02*sj4);
IkReal x682=((0.27)*cj3);
IkReal x683=((0.27)*sj3);
IkReal x684=(cj5*r01);
IkReal x685=(r01*sj5);
IkReal x686=((4.63308)*sj4);
IkReal x687=(cj5*r21);
IkReal x688=((0.81)*sj3);
IkReal x689=((4.63308)*cj4);
IkReal x690=(cj5*r20);
IkReal x691=(cj4*r02);
IkReal x692=((1.54436)*sj4);
IkReal x693=((0.09)*x677);
IkReal x694=(cj4*r00*sj5);
IkReal x695=(r20*sj4*sj5);
IkReal x696=(r00*sj4*sj5);
IkReal x697=(x679*x681);
IkReal x698=(x685*x688);
IkReal x699=(x676+x697+x693+x698);
IkReal x700=(((r00*sj5*x686))+((cj4*x679*x684))+((x677*x688))+((x679*x694))+(((0.09)*x685))+((x684*x686))+((r02*x689)));
j1eval[0]=((5.0)+(((0.5)*(IKabs(((1.25)+(((-1.0)*x700))+x699)))))+(((0.5)*(IKabs(((-1.25)+(((0.03)*x677))+(((-1.0)*x684*x692))+(((4.0)*px))+((x683*x685))+(((-1.0)*r02*x680))+(((-1.0)*x682*x694))+(((-1.0)*r00*sj5*x692))+(((-1.0)*cj4*x682*x684))+((x681*x682))+(((-0.03)*x685))+(((-1.0)*x677*x683)))))))+(IKabs(((((0.81)*sj4*x684))+(((12.0)*pz))+(((0.81)*x691))+(((0.81)*x696))+(((-1.0)*x686*x687))+(((-0.09)*x678))+(((-1.0)*r20*sj5*x686))+(((-1.0)*r22*x689))+(((0.09)*x690)))))+(((0.5)*(IKabs(((-1.25)+(((-1.0)*x700))+x699)))))+(((0.5)*(IKabs(((((-1.0)*x687*x692))+(((4.0)*pz))+(((-1.0)*r20*sj5*x692))+(((0.27)*sj4*x684))+(((0.03)*x690))+(((0.27)*x696))+(((0.27)*x691))+(((-1.0)*r22*x680))+(((-0.03)*x678))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x701=(cj5*sj4);
IkReal x702=(cj4*r22);
IkReal x703=(r21*sj5);
IkReal x704=(cj4*r02);
IkReal x705=(cj5*r20);
IkReal x706=(r20*sj4*sj5);
IkReal x707=(r00*sj4*sj5);
IkReal x708=((((0.81)*r01*x701))+(((0.81)*x704))+(((0.81)*x707))+(((0.09)*x705))+(((12.0)*pz))+(((-4.63308)*x702))+(((-4.63308)*x706))+(((-0.09)*x703))+(((-4.63308)*r21*x701)));
IkReal x709=((((0.27)*x707))+(((0.27)*x704))+(((0.27)*r01*x701))+(((-0.03)*x703))+(((4.0)*pz))+(((0.03)*x705))+(((-1.54436)*x706))+(((-1.54436)*x702))+(((-1.54436)*r21*x701)));
op[0]=x709;
op[1]=2.5;
op[2]=x708;
op[3]=5.0;
op[4]=x708;
op[5]=2.5;
op[6]=x709;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x710=((4.0)*px);
IkReal x711=((12.0)*px);
IkReal x712=(cj5*r00);
IkReal x713=((0.81)*cj3);
IkReal x714=(r02*sj4);
IkReal x715=((0.27)*cj3);
IkReal x716=(cj4*r02);
IkReal x717=((0.27)*sj3);
IkReal x718=(cj5*r01);
IkReal x719=(r01*sj5);
IkReal x720=((0.81)*sj3);
IkReal x721=((0.03)*x712);
IkReal x722=((0.09)*x712);
IkReal x723=(cj4*r00*sj5);
IkReal x724=(r00*sj4*sj5);
IkReal x725=(x714*x715);
IkReal x726=(x717*x719);
IkReal x727=(x713*x714);
IkReal x728=(x719*x720);
IkReal x729=(x711+x722+x727+x728);
IkReal x730=(x710+x721+x725+x726);
IkReal x731=(((x712*x720))+(((0.09)*x719))+((x713*x723))+((cj4*x713*x718))+(((4.63308)*x724))+(((4.63308)*x716))+(((4.63308)*sj4*x718)));
IkReal x732=(((cj4*x715*x718))+(((1.54436)*x716))+(((1.54436)*x724))+(((0.03)*x719))+((x712*x717))+(((1.54436)*sj4*x718))+((x715*x723)));
j1evalpoly[0]=((1.25)+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((-1.25)+(((-1.0)*x732))+x730))))+(((htj1*htj1*htj1*htj1)*(((-1.25)+(((-1.0)*x731))+x729))))+(((-1.0)*x732))+x730+(((htj1*htj1)*(((1.25)+(((-1.0)*x731))+x729)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x733=((1.0)*cj1);
IkReal x734=(cj4*r22);
IkReal x735=(cj4*r02);
IkReal x736=((1.0)*sj1);
IkReal x737=(cj5*sj4);
IkReal x738=(r20*sj4*sj5);
IkReal x739=(r00*sj4*sj5);
if( IKabs((((r01*sj1*x737))+(((-1.0)*r21*x733*x737))+(((-1.0)*x733*x738))+(((-1.0)*x733*x734))+((sj1*x739))+((sj1*x735)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x736*x738))+(((-1.0)*r01*x733*x737))+(((-1.0)*x734*x736))+(((-1.0)*x733*x739))+(((-1.0)*x733*x735))+(((-1.0)*r21*x736*x737)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj1*x737))+(((-1.0)*r21*x733*x737))+(((-1.0)*x733*x738))+(((-1.0)*x733*x734))+((sj1*x739))+((sj1*x735))))+IKsqr(((((-1.0)*x736*x738))+(((-1.0)*r01*x733*x737))+(((-1.0)*x734*x736))+(((-1.0)*x733*x739))+(((-1.0)*x733*x735))+(((-1.0)*r21*x736*x737))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((r01*sj1*x737))+(((-1.0)*r21*x733*x737))+(((-1.0)*x733*x738))+(((-1.0)*x733*x734))+((sj1*x739))+((sj1*x735))), ((((-1.0)*x736*x738))+(((-1.0)*r01*x733*x737))+(((-1.0)*x734*x736))+(((-1.0)*x733*x739))+(((-1.0)*x733*x735))+(((-1.0)*r21*x736*x737))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x740=IKcos(j2);
IkReal x741=IKsin(j2);
IkReal x742=(cj3*sj4);
IkReal x743=((1.0)*cj5);
IkReal x744=(cj3*cj4);
IkReal x745=(r21*sj5);
IkReal x746=((1.0)*sj5);
IkReal x747=((1.0)*cj4);
IkReal x748=(r01*sj5);
IkReal x749=((0.0075)*cj5);
IkReal x750=(cj1*x740);
IkReal x751=(cj1*x741);
IkReal x752=(sj1*x740);
IkReal x753=(sj1*x741);
IkReal x754=((1.0)*x752);
IkReal x755=((1.0)*x751);
IkReal x756=(x755+x754);
evalcond[0]=((((-1.0)*r02*x747))+(((-1.0)*r01*sj4*x743))+(((-1.0)*x750))+x753+(((-1.0)*r00*sj4*x746)));
evalcond[1]=((((-1.0)*r20*sj4*x746))+(((-1.0)*r22*x747))+(((-1.0)*r21*sj4*x743))+(((-1.0)*x756)));
evalcond[2]=((((-1.0)*r20*x744*x746))+((r22*x742))+(((-1.0)*r21*x743*x744))+(((-1.0)*r20*sj3*x743))+((sj3*x745))+(((-1.0)*x753))+x750);
evalcond[3]=(((r02*x742))+(((-1.0)*r00*sj3*x743))+(((-1.0)*r00*x744*x746))+((sj3*x748))+(((-1.0)*r01*x743*x744))+(((-1.0)*x756)));
evalcond[4]=((((-1.0)*r20*x749))+(((-0.0675)*x753))+(((-0.3125)*sj1))+(((0.0075)*x745))+(((-1.0)*pz))+(((-0.38609)*x751))+(((-0.38609)*x752))+(((0.0675)*x750)));
evalcond[5]=((((-0.0675)*x752))+(((-0.0675)*x751))+(((0.0075)*x748))+(((-1.0)*px))+(((-1.0)*r00*x749))+(((-0.38609)*x750))+(((0.38609)*x753))+(((-0.3125)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x757=((1.0)*cj5);
IkReal x758=(((cj4*r22))+((cj5*r21*sj4))+((r20*sj4*sj5)));
j3eval[0]=x758;
j3eval[1]=IKsign(x758);
j3eval[2]=((IKabs(((((-1.0)*cj4*r10*sj5))+((r12*sj4))+(((-1.0)*cj4*r11*x757)))))+(IKabs(((((-1.0)*r10*x757))+((r11*sj5))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x759=((1.0)*sj5);
IkReal x760=((1.0)*cj5);
IkReal x761=((((-1.0)*r11*sj4*x760))+(((-1.0)*cj4*r12))+(((-1.0)*r10*sj4*x759)));
j3eval[0]=x761;
j3eval[1]=((IKabs((((r21*sj5))+(((-1.0)*r20*x760)))))+(IKabs((((r22*sj4))+(((-1.0)*cj4*r20*x759))+(((-1.0)*cj4*r21*x760))))));
j3eval[2]=IKsign(x761);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x762=cj5*cj5;
IkReal x763=cj4*cj4;
IkReal x764=r00*r00;
IkReal x765=r01*r01;
IkReal x766=r02*r02;
IkReal x767=(r00*sj5);
IkReal x768=((1.0)*r01);
IkReal x769=((2.0)*cj5*r01);
IkReal x770=(cj4*r02*sj4);
IkReal x771=((1.0)*x765);
IkReal x772=(x762*x764);
IkReal x773=((((2.0)*x767*x770))+(((-1.0)*x763*x767*x769))+((x769*x770))+((x763*x766))+((x762*x765))+(((-1.0)*x766))+((x763*x772))+(((-1.0)*x763*x764))+(((-1.0)*x771))+(((-1.0)*x772))+((x767*x769))+(((-1.0)*x762*x763*x771)));
j3eval[0]=x773;
j3eval[1]=((IKabs(((((-1.0)*sj5*x768))+((cj5*r00)))))+(IKabs((((r02*sj4))+(((-1.0)*cj4*cj5*x768))+(((-1.0)*cj4*x767))))));
j3eval[2]=IKsign(x773);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x774=cj5*cj5;
IkReal x775=cj4*cj4;
IkReal x776=r00*r00;
IkReal x777=r01*r01;
IkReal x778=r02*r02;
IkReal x779=(cj5*r01);
IkReal x780=((1.0)*sj5);
IkReal x781=(r00*sj5);
IkReal x782=((1.0)*x776);
IkReal x783=((2.0)*cj4*r02*sj4);
IkReal x784=(x774*x777);
CheckValue<IkReal> x785=IKPowWithIntegerCheck(IKsign((((x781*x783))+(((-1.0)*x775*x784))+(((-1.0)*x775*x782))+((x774*x775*x776))+((x779*x783))+(((-2.0)*x775*x779*x781))+x784+(((-1.0)*x774*x782))+(((-1.0)*x778))+(((-1.0)*x777))+((x775*x778))+(((2.0)*x779*x781)))),-1);
if(!x785.valid){
continue;
}
CheckValue<IkReal> x786 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*r00*x780))+((r02*sj4))+(((-1.0)*cj4*x779)))),IkReal(((((-1.0)*r01*x780))+((cj5*r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x786.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x785.value)))+(x786.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x787=IKsin(j3);
IkReal x788=IKcos(j3);
IkReal x789=(cj4*cj5);
IkReal x790=(cj5*r00);
IkReal x791=(r02*sj4);
IkReal x792=((1.0)*x788);
IkReal x793=(r01*x787);
IkReal x794=((1.0)*x787);
IkReal x795=(sj5*x788);
IkReal x796=(cj4*sj5*x787);
evalcond[0]=(((r20*x796))+((r21*x795))+(((-1.0)*r22*sj4*x794))+((r21*x787*x789))+(((-1.0)*cj5*r20*x792)));
evalcond[1]=(((r10*x796))+(((-1.0)*r12*sj4*x794))+(((-1.0)*cj5*r10*x792))+((r11*x787*x789))+((r11*x795)));
evalcond[2]=((-1.0)+((r00*x796))+((r01*x795))+(((-1.0)*x791*x794))+(((-1.0)*x790*x792))+((x789*x793)));
evalcond[3]=(((sj5*x793))+(((-1.0)*cj4*r00*sj5*x792))+(((-1.0)*r01*x789*x792))+((x788*x791))+(((-1.0)*x790*x794)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x797=((4.63308)*py);
IkReal x798=((0.81)*pz);
IkReal x799=(cj5*r20);
IkReal x800=(r11*sj5);
IkReal x801=(cj4*r12);
IkReal x802=(cj5*r10);
IkReal x803=(cj5*sj4);
IkReal x804=(cj4*r22);
IkReal x805=(r21*sj5);
IkReal x806=((4.63308)*x801);
IkReal x807=((0.09)*x800);
IkReal x808=((0.006075)*x799);
IkReal x809=((0.0347481)*x802);
IkReal x810=(r10*sj4*sj5);
IkReal x811=(r20*sj4*sj5);
IkReal x812=((4.63308)*r11*x803);
IkReal x813=((4.63308)*x810);
IkReal x814=(x797+x798+x809+x808);
IkReal x815=(x812+x813+x807+x806);
IkReal x816=((((12.0)*py))+(((0.81)*x804))+(((0.09)*x802))+(((0.81)*x811))+(((0.81)*r21*x803)));
IkReal x817=((((1.8434608572)*x810))+(((1.8434608572)*x801))+(((1.8434608572)*r11*x803))+(((0.006075)*x805))+(((0.0347481)*x800)));
j1eval[0]=((1.0)+(((1.48148148148148)*(IKabs(((0.4826125)+(((-1.0)*x817))+x814)))))+(((1.48148148148148)*(IKabs(((-0.4826125)+(((-1.0)*x817))+x814)))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((0.0115827)*x802))+(((-0.6144869524)*r11*x803))+(((0.002025)*x799))+(((0.27)*pz))+(((-0.6144869524)*x810))+(((-0.0115827)*x800))+(((1.54436)*py))+(((-0.002025)*x805))+(((-0.6144869524)*x801)))))))+(((1.48148148148148)*(IKabs(((-1.25)+(((-1.0)*x816))+x815)))))+(((1.48148148148148)*(IKabs(((-1.25)+(((1.54436)*r11*x803))+(((0.03)*x800))+(((-0.03)*x802))+(((1.54436)*x810))+(((-0.27)*r21*x803))+(((-0.27)*x804))+(((-4.0)*py))+(((1.54436)*x801))+(((-0.27)*x811)))))))+(((1.48148148148148)*(IKabs(((1.25)+(((-1.0)*x816))+x815))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x818=(sj4*sj5);
IkReal x819=(cj4*r22);
IkReal x820=(cj4*r12);
IkReal x821=(cj5*r10);
IkReal x822=(r11*sj5);
IkReal x823=((4.63308)*x820);
IkReal x824=((0.09)*x822);
IkReal x825=((1.54436)*x820);
IkReal x826=((0.03)*x822);
IkReal x827=(cj5*r21*sj4);
IkReal x828=(cj5*r11*sj4);
IkReal x829=((4.63308)*x828);
IkReal x830=((4.63308)*r10*x818);
IkReal x831=((1.54436)*r10*x818);
IkReal x832=((1.54436)*x828);
IkReal x833=(x829+x823+x824+x830);
IkReal x834=(x826+x825+x831+x832);
IkReal x835=((((0.09)*x821))+(((12.0)*py))+(((0.81)*r20*x818))+(((0.81)*x819))+(((0.81)*x827)));
IkReal x836=((((4.0)*py))+(((0.03)*x821))+(((0.27)*r20*x818))+(((0.27)*x827))+(((0.27)*x819)));
op[0]=((-1.25)+(((-1.0)*x836))+x834);
op[1]=0;
op[2]=((-1.25)+(((-1.0)*x835))+x833);
op[3]=0;
op[4]=((1.25)+(((-1.0)*x835))+x833);
op[5]=0;
op[6]=((1.25)+(((-1.0)*x836))+x834);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x837=((0.27)*pz);
IkReal x838=((1.54436)*py);
IkReal x839=((4.63308)*py);
IkReal x840=((0.81)*pz);
IkReal x841=(cj5*r20);
IkReal x842=(cj5*r10);
IkReal x843=(cj4*r12);
IkReal x844=((1.8434608572)*sj4);
IkReal x845=(r10*sj5);
IkReal x846=(r11*sj5);
IkReal x847=(cj5*r11);
IkReal x848=((0.6144869524)*sj4);
IkReal x849=(r21*sj5);
IkReal x850=((0.002025)*x841);
IkReal x851=((0.0115827)*x842);
IkReal x852=((0.006075)*x841);
IkReal x853=((0.0347481)*x842);
IkReal x854=(x850+x851+x837+x838);
IkReal x855=(x852+x853+x839+x840);
IkReal x856=((((0.0347481)*x846))+(((1.8434608572)*x843))+(((0.006075)*x849))+((x844*x845))+((x844*x847)));
IkReal x857=((((0.0115827)*x846))+(((0.6144869524)*x843))+((x845*x848))+(((0.002025)*x849))+((x847*x848)));
j1evalpoly[0]=((-0.4826125)+(((-1.0)*x857))+(((htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x856))+x855))))+(((0.16875)*htj1))+(((0.3375)*(htj1*htj1*htj1)))+(((htj1*htj1)*(((-0.4826125)+(((-1.0)*x856))+x855))))+(((0.16875)*(htj1*htj1*htj1*htj1*htj1)))+x854+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x857))+x854)))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x858=((1.0)*cj1);
IkReal x859=(cj4*r22);
IkReal x860=(sj4*sj5);
IkReal x861=(cj5*sj4);
IkReal x862=(cj4*r12);
IkReal x863=((1.0)*sj1);
if( IKabs(((((-1.0)*r11*x861*x863))+(((-1.0)*x862*x863))+(((-1.0)*r21*x858*x861))+(((-1.0)*x858*x859))+(((-1.0)*r10*x860*x863))+(((-1.0)*r20*x858*x860)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r10*x860))+(((-1.0)*r21*x861*x863))+((cj1*x862))+(((-1.0)*x859*x863))+((cj1*r11*x861))+(((-1.0)*r20*x860*x863)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r11*x861*x863))+(((-1.0)*x862*x863))+(((-1.0)*r21*x858*x861))+(((-1.0)*x858*x859))+(((-1.0)*r10*x860*x863))+(((-1.0)*r20*x858*x860))))+IKsqr((((cj1*r10*x860))+(((-1.0)*r21*x861*x863))+((cj1*x862))+(((-1.0)*x859*x863))+((cj1*r11*x861))+(((-1.0)*r20*x860*x863))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r11*x861*x863))+(((-1.0)*x862*x863))+(((-1.0)*r21*x858*x861))+(((-1.0)*x858*x859))+(((-1.0)*r10*x860*x863))+(((-1.0)*r20*x858*x860))), (((cj1*r10*x860))+(((-1.0)*r21*x861*x863))+((cj1*x862))+(((-1.0)*x859*x863))+((cj1*r11*x861))+(((-1.0)*r20*x860*x863))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x864=IKcos(j2);
IkReal x865=IKsin(j2);
IkReal x866=(cj5*r10);
IkReal x867=((1.0)*sj3);
IkReal x868=(cj5*r20);
IkReal x869=(r11*sj5);
IkReal x870=(r21*sj5);
IkReal x871=((1.0)*cj4);
IkReal x872=((1.0)*sj1);
IkReal x873=(cj3*sj4);
IkReal x874=(cj3*sj5);
IkReal x875=(cj3*cj5);
IkReal x876=(cj1*x864);
IkReal x877=(cj1*x865);
IkReal x878=((1.0)*sj4*sj5);
IkReal x879=(sj1*x864);
IkReal x880=((1.0)*cj5*sj4);
IkReal x881=(sj1*x865);
IkReal x882=(x865*x872);
evalcond[0]=((((-1.0)*r12*x871))+(((-1.0)*x882))+(((-1.0)*r11*x880))+x876+(((-1.0)*r10*x878)));
evalcond[1]=((((-1.0)*x877))+(((-1.0)*x864*x872))+(((-1.0)*r20*x878))+(((-1.0)*r22*x871))+(((-1.0)*r21*x880)));
evalcond[2]=(((sj3*x869))+(((-1.0)*x866*x867))+((r12*x873))+(((-1.0)*r11*x871*x875))+x879+x877+(((-1.0)*r10*x871*x874)));
evalcond[3]=((((-1.0)*r21*x871*x875))+((sj3*x870))+((r22*x873))+(((-1.0)*x882))+(((-1.0)*r20*x871*x874))+x876+(((-1.0)*x867*x868)));
evalcond[4]=((((-0.3125)*sj1))+(((-0.38609)*x877))+(((-0.38609)*x879))+(((-0.0075)*x868))+(((-0.0675)*x881))+(((-1.0)*pz))+(((0.0075)*x870))+(((0.0675)*x876)));
evalcond[5]=((((-0.38609)*x881))+(((0.3125)*cj1))+(((-0.0075)*x866))+(((0.0075)*x869))+(((-1.0)*py))+(((0.38609)*x876))+(((0.0675)*x877))+(((0.0675)*x879)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x883=((1.0)*sj5);
IkReal x884=((1.0)*cj5);
CheckValue<IkReal> x885=IKPowWithIntegerCheck(IKsign(((((-1.0)*r11*sj4*x884))+(((-1.0)*r10*sj4*x883))+(((-1.0)*cj4*r12)))),-1);
if(!x885.valid){
continue;
}
CheckValue<IkReal> x886 = IKatan2WithCheck(IkReal((((r21*sj5))+(((-1.0)*r20*x884)))),IkReal((((r22*sj4))+(((-1.0)*cj4*r21*x884))+(((-1.0)*cj4*r20*x883)))),IKFAST_ATAN2_MAGTHRESH);
if(!x886.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x885.value)))+(x886.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x887=IKsin(j3);
IkReal x888=IKcos(j3);
IkReal x889=(cj4*cj5);
IkReal x890=(cj5*r00);
IkReal x891=(r02*sj4);
IkReal x892=((1.0)*x888);
IkReal x893=(r01*x887);
IkReal x894=((1.0)*x887);
IkReal x895=(sj5*x888);
IkReal x896=(cj4*sj5*x887);
evalcond[0]=((((-1.0)*r22*sj4*x894))+((r20*x896))+((r21*x887*x889))+(((-1.0)*cj5*r20*x892))+((r21*x895)));
evalcond[1]=(((r11*x887*x889))+((r11*x895))+(((-1.0)*r12*sj4*x894))+((r10*x896))+(((-1.0)*cj5*r10*x892)));
evalcond[2]=((-1.0)+((r01*x895))+((r00*x896))+((x889*x893))+(((-1.0)*x890*x892))+(((-1.0)*x891*x894)));
evalcond[3]=((((-1.0)*cj4*r00*sj5*x892))+(((-1.0)*r01*x889*x892))+((sj5*x893))+((x888*x891))+(((-1.0)*x890*x894)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x897=((4.63308)*py);
IkReal x898=((0.81)*pz);
IkReal x899=(cj5*r20);
IkReal x900=(r11*sj5);
IkReal x901=(cj4*r12);
IkReal x902=(cj5*r10);
IkReal x903=(cj5*sj4);
IkReal x904=(cj4*r22);
IkReal x905=(r21*sj5);
IkReal x906=((4.63308)*x901);
IkReal x907=((0.09)*x900);
IkReal x908=((0.006075)*x899);
IkReal x909=((0.0347481)*x902);
IkReal x910=(r10*sj4*sj5);
IkReal x911=(r20*sj4*sj5);
IkReal x912=((4.63308)*r11*x903);
IkReal x913=((4.63308)*x910);
IkReal x914=(x897+x898+x908+x909);
IkReal x915=(x913+x912+x906+x907);
IkReal x916=((((0.81)*x904))+(((0.09)*x902))+(((12.0)*py))+(((0.81)*r21*x903))+(((0.81)*x911)));
IkReal x917=((((0.0347481)*x900))+(((1.8434608572)*x910))+(((0.006075)*x905))+(((1.8434608572)*r11*x903))+(((1.8434608572)*x901)));
j1eval[0]=((1.0)+(((1.48148148148148)*(IKabs(((-0.4826125)+(((-1.0)*x917))+x914)))))+(((1.48148148148148)*(IKabs(((-1.25)+(((-1.0)*x916))+x915)))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((0.27)*pz))+(((1.54436)*py))+(((-0.6144869524)*x910))+(((-0.0115827)*x900))+(((-0.6144869524)*x901))+(((-0.002025)*x905))+(((0.0115827)*x902))+(((-0.6144869524)*r11*x903))+(((0.002025)*x899)))))))+(((1.48148148148148)*(IKabs(((-1.25)+(((-0.27)*r21*x903))+(((-0.03)*x902))+(((-0.27)*x904))+(((1.54436)*r11*x903))+(((-0.27)*x911))+(((1.54436)*x910))+(((0.03)*x900))+(((1.54436)*x901))+(((-4.0)*py)))))))+(((1.48148148148148)*(IKabs(((1.25)+(((-1.0)*x916))+x915)))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((-1.0)*x917))+x914))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x918=(sj4*sj5);
IkReal x919=(cj4*r22);
IkReal x920=(cj4*r12);
IkReal x921=(cj5*r10);
IkReal x922=(r11*sj5);
IkReal x923=((4.63308)*x920);
IkReal x924=((0.09)*x922);
IkReal x925=((1.54436)*x920);
IkReal x926=((0.03)*x922);
IkReal x927=(cj5*r21*sj4);
IkReal x928=(cj5*r11*sj4);
IkReal x929=((4.63308)*x928);
IkReal x930=((4.63308)*r10*x918);
IkReal x931=((1.54436)*r10*x918);
IkReal x932=((1.54436)*x928);
IkReal x933=(x930+x929+x924+x923);
IkReal x934=(x931+x932+x926+x925);
IkReal x935=((((12.0)*py))+(((0.81)*r20*x918))+(((0.81)*x927))+(((0.09)*x921))+(((0.81)*x919)));
IkReal x936=((((0.03)*x921))+(((0.27)*x919))+(((4.0)*py))+(((0.27)*r20*x918))+(((0.27)*x927)));
op[0]=((-1.25)+x934+(((-1.0)*x936)));
op[1]=0;
op[2]=((-1.25)+x933+(((-1.0)*x935)));
op[3]=0;
op[4]=((1.25)+x933+(((-1.0)*x935)));
op[5]=0;
op[6]=((1.25)+x934+(((-1.0)*x936)));
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x937=((0.27)*pz);
IkReal x938=((1.54436)*py);
IkReal x939=((4.63308)*py);
IkReal x940=((0.81)*pz);
IkReal x941=(cj5*r20);
IkReal x942=(cj5*r10);
IkReal x943=(cj4*r12);
IkReal x944=((1.8434608572)*sj4);
IkReal x945=(r10*sj5);
IkReal x946=(r11*sj5);
IkReal x947=(cj5*r11);
IkReal x948=((0.6144869524)*sj4);
IkReal x949=(r21*sj5);
IkReal x950=((0.002025)*x941);
IkReal x951=((0.0115827)*x942);
IkReal x952=((0.006075)*x941);
IkReal x953=((0.0347481)*x942);
IkReal x954=(x938+x937+x951+x950);
IkReal x955=(x939+x953+x952+x940);
IkReal x956=((((0.006075)*x949))+(((1.8434608572)*x943))+((x944*x947))+((x944*x945))+(((0.0347481)*x946)));
IkReal x957=((((0.002025)*x949))+(((0.6144869524)*x943))+((x945*x948))+((x947*x948))+(((0.0115827)*x946)));
j1evalpoly[0]=((-0.4826125)+(((htj1*htj1)*(((-0.4826125)+(((-1.0)*x956))+x955))))+(((0.16875)*htj1))+(((0.3375)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x956))+x955))))+(((0.16875)*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x957))+x954))))+(((-1.0)*x957))+x954);
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x958=((1.0)*cj1);
IkReal x959=(cj4*r22);
IkReal x960=(sj4*sj5);
IkReal x961=(cj5*sj4);
IkReal x962=(cj4*r12);
IkReal x963=((1.0)*sj1);
if( IKabs(((((-1.0)*r11*x961*x963))+(((-1.0)*x962*x963))+(((-1.0)*r10*x960*x963))+(((-1.0)*r20*x958*x960))+(((-1.0)*x958*x959))+(((-1.0)*r21*x958*x961)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r21*x961*x963))+(((-1.0)*r20*x960*x963))+((cj1*x962))+(((-1.0)*x959*x963))+((cj1*r11*x961))+((cj1*r10*x960)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r11*x961*x963))+(((-1.0)*x962*x963))+(((-1.0)*r10*x960*x963))+(((-1.0)*r20*x958*x960))+(((-1.0)*x958*x959))+(((-1.0)*r21*x958*x961))))+IKsqr(((((-1.0)*r21*x961*x963))+(((-1.0)*r20*x960*x963))+((cj1*x962))+(((-1.0)*x959*x963))+((cj1*r11*x961))+((cj1*r10*x960))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r11*x961*x963))+(((-1.0)*x962*x963))+(((-1.0)*r10*x960*x963))+(((-1.0)*r20*x958*x960))+(((-1.0)*x958*x959))+(((-1.0)*r21*x958*x961))), ((((-1.0)*r21*x961*x963))+(((-1.0)*r20*x960*x963))+((cj1*x962))+(((-1.0)*x959*x963))+((cj1*r11*x961))+((cj1*r10*x960))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x964=IKcos(j2);
IkReal x965=IKsin(j2);
IkReal x966=(cj5*r10);
IkReal x967=((1.0)*sj3);
IkReal x968=(cj5*r20);
IkReal x969=(r11*sj5);
IkReal x970=(r21*sj5);
IkReal x971=((1.0)*cj4);
IkReal x972=((1.0)*sj1);
IkReal x973=(cj3*sj4);
IkReal x974=(cj3*sj5);
IkReal x975=(cj3*cj5);
IkReal x976=(cj1*x964);
IkReal x977=(cj1*x965);
IkReal x978=((1.0)*sj4*sj5);
IkReal x979=(sj1*x964);
IkReal x980=((1.0)*cj5*sj4);
IkReal x981=(sj1*x965);
IkReal x982=(x965*x972);
evalcond[0]=((((-1.0)*x982))+(((-1.0)*r12*x971))+(((-1.0)*r11*x980))+x976+(((-1.0)*r10*x978)));
evalcond[1]=((((-1.0)*r20*x978))+(((-1.0)*r21*x980))+(((-1.0)*x977))+(((-1.0)*x964*x972))+(((-1.0)*r22*x971)));
evalcond[2]=((((-1.0)*r11*x971*x975))+(((-1.0)*x966*x967))+((r12*x973))+((sj3*x969))+(((-1.0)*r10*x971*x974))+x977+x979);
evalcond[3]=((((-1.0)*x982))+(((-1.0)*r21*x971*x975))+((r22*x973))+(((-1.0)*x967*x968))+(((-1.0)*r20*x971*x974))+x976+((sj3*x970)));
evalcond[4]=((((-0.38609)*x977))+(((-0.38609)*x979))+(((-0.3125)*sj1))+(((-1.0)*pz))+(((0.0675)*x976))+(((-0.0675)*x981))+(((0.0075)*x970))+(((-0.0075)*x968)));
evalcond[5]=((((-0.38609)*x981))+(((0.3125)*cj1))+(((-1.0)*py))+(((0.0075)*x969))+(((0.0675)*x977))+(((0.0675)*x979))+(((0.38609)*x976))+(((-0.0075)*x966)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x983=((1.0)*cj5);
CheckValue<IkReal> x984 = IKatan2WithCheck(IkReal(((((-1.0)*r10*x983))+((r11*sj5)))),IkReal(((((-1.0)*cj4*r11*x983))+(((-1.0)*cj4*r10*sj5))+((r12*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x984.valid){
continue;
}
CheckValue<IkReal> x985=IKPowWithIntegerCheck(IKsign((((cj4*r22))+((cj5*r21*sj4))+((r20*sj4*sj5)))),-1);
if(!x985.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x984.value)+(((1.5707963267949)*(x985.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x986=IKsin(j3);
IkReal x987=IKcos(j3);
IkReal x988=(cj4*cj5);
IkReal x989=(cj5*r00);
IkReal x990=(r02*sj4);
IkReal x991=((1.0)*x987);
IkReal x992=(r01*x986);
IkReal x993=((1.0)*x986);
IkReal x994=(sj5*x987);
IkReal x995=(cj4*sj5*x986);
evalcond[0]=(((r21*x986*x988))+(((-1.0)*cj5*r20*x991))+((r20*x995))+((r21*x994))+(((-1.0)*r22*sj4*x993)));
evalcond[1]=((((-1.0)*cj5*r10*x991))+((r11*x986*x988))+(((-1.0)*r12*sj4*x993))+((r10*x995))+((r11*x994)));
evalcond[2]=((-1.0)+((x988*x992))+((r01*x994))+((r00*x995))+(((-1.0)*x990*x993))+(((-1.0)*x989*x991)));
evalcond[3]=((((-1.0)*r01*x988*x991))+((sj5*x992))+(((-1.0)*cj4*r00*sj5*x991))+((x987*x990))+(((-1.0)*x989*x993)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=1.0;
cj0=0;
j0=1.5707963267949;
IkReal x996=((4.63308)*py);
IkReal x997=((0.81)*pz);
IkReal x998=(cj5*r20);
IkReal x999=(r11*sj5);
IkReal x1000=(cj4*r12);
IkReal x1001=(cj5*r10);
IkReal x1002=(cj5*sj4);
IkReal x1003=(cj4*r22);
IkReal x1004=(r21*sj5);
IkReal x1005=((4.63308)*x1000);
IkReal x1006=((0.09)*x999);
IkReal x1007=((0.006075)*x998);
IkReal x1008=((0.0347481)*x1001);
IkReal x1009=(r10*sj4*sj5);
IkReal x1010=(r20*sj4*sj5);
IkReal x1011=((4.63308)*r11*x1002);
IkReal x1012=((4.63308)*x1009);
IkReal x1013=(x1008+x1007+x997+x996);
IkReal x1014=(x1011+x1012+x1006+x1005);
IkReal x1015=((((0.81)*x1003))+(((0.81)*r21*x1002))+(((12.0)*py))+(((0.09)*x1001))+(((0.81)*x1010)));
IkReal x1016=((((0.0347481)*x999))+(((1.8434608572)*x1009))+(((1.8434608572)*x1000))+(((0.006075)*x1004))+(((1.8434608572)*r11*x1002)));
j1eval[0]=((1.0)+(((1.48148148148148)*(IKabs(((-1.25)+(((-0.27)*x1003))+(((-0.27)*x1010))+(((-0.27)*r21*x1002))+(((0.03)*x999))+(((1.54436)*x1000))+(((1.54436)*x1009))+(((1.54436)*r11*x1002))+(((-0.03)*x1001))+(((-4.0)*py)))))))+(((1.48148148148148)*(IKabs(((0.4826125)+(((-0.6144869524)*x1000))+(((-0.6144869524)*x1009))+(((0.0115827)*x1001))+(((0.27)*pz))+(((1.54436)*py))+(((-0.002025)*x1004))+(((0.002025)*x998))+(((-0.6144869524)*r11*x1002))+(((-0.0115827)*x999)))))))+(((1.48148148148148)*(IKabs(((-1.25)+x1014+(((-1.0)*x1015)))))))+(((1.48148148148148)*(IKabs(((-0.4826125)+x1013+(((-1.0)*x1016)))))))+(((1.48148148148148)*(IKabs(((1.25)+x1014+(((-1.0)*x1015)))))))+(((1.48148148148148)*(IKabs(((0.4826125)+x1013+(((-1.0)*x1016))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1017=(sj4*sj5);
IkReal x1018=(cj4*r22);
IkReal x1019=(cj4*r12);
IkReal x1020=(cj5*r10);
IkReal x1021=(r11*sj5);
IkReal x1022=((4.63308)*x1019);
IkReal x1023=((0.09)*x1021);
IkReal x1024=((1.54436)*x1019);
IkReal x1025=((0.03)*x1021);
IkReal x1026=(cj5*r21*sj4);
IkReal x1027=(cj5*r11*sj4);
IkReal x1028=((4.63308)*x1027);
IkReal x1029=((4.63308)*r10*x1017);
IkReal x1030=((1.54436)*r10*x1017);
IkReal x1031=((1.54436)*x1027);
IkReal x1032=(x1023+x1022+x1029+x1028);
IkReal x1033=(x1030+x1031+x1025+x1024);
IkReal x1034=((((12.0)*py))+(((0.09)*x1020))+(((0.81)*x1026))+(((0.81)*x1018))+(((0.81)*r20*x1017)));
IkReal x1035=((((0.27)*x1026))+(((4.0)*py))+(((0.27)*r20*x1017))+(((0.03)*x1020))+(((0.27)*x1018)));
op[0]=((-1.25)+(((-1.0)*x1035))+x1033);
op[1]=0;
op[2]=((-1.25)+(((-1.0)*x1034))+x1032);
op[3]=0;
op[4]=((1.25)+(((-1.0)*x1034))+x1032);
op[5]=0;
op[6]=((1.25)+(((-1.0)*x1035))+x1033);
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1036=((0.27)*pz);
IkReal x1037=((1.54436)*py);
IkReal x1038=((4.63308)*py);
IkReal x1039=((0.81)*pz);
IkReal x1040=(cj5*r20);
IkReal x1041=(cj5*r10);
IkReal x1042=(cj4*r12);
IkReal x1043=((1.8434608572)*sj4);
IkReal x1044=(r10*sj5);
IkReal x1045=(r11*sj5);
IkReal x1046=(cj5*r11);
IkReal x1047=((0.6144869524)*sj4);
IkReal x1048=(r21*sj5);
IkReal x1049=((0.002025)*x1040);
IkReal x1050=((0.0115827)*x1041);
IkReal x1051=((0.006075)*x1040);
IkReal x1052=((0.0347481)*x1041);
IkReal x1053=(x1050+x1049+x1036+x1037);
IkReal x1054=(x1051+x1052+x1038+x1039);
IkReal x1055=((((0.0347481)*x1045))+((x1043*x1044))+((x1043*x1046))+(((1.8434608572)*x1042))+(((0.006075)*x1048)));
IkReal x1056=((((0.6144869524)*x1042))+(((0.0115827)*x1045))+(((0.002025)*x1048))+((x1046*x1047))+((x1044*x1047)));
j1evalpoly[0]=((-0.4826125)+(((-1.0)*x1056))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x1056))+x1053))))+x1053+(((0.16875)*htj1))+(((0.3375)*(htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1)*(((0.4826125)+(((-1.0)*x1055))+x1054))))+(((htj1*htj1)*(((-0.4826125)+(((-1.0)*x1055))+x1054))))+(((0.16875)*(htj1*htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1057=((1.0)*cj1);
IkReal x1058=(cj4*r22);
IkReal x1059=(sj4*sj5);
IkReal x1060=(cj5*sj4);
IkReal x1061=(cj4*r12);
IkReal x1062=((1.0)*sj1);
if( IKabs(((((-1.0)*r10*x1059*x1062))+(((-1.0)*r20*x1057*x1059))+(((-1.0)*r11*x1060*x1062))+(((-1.0)*x1061*x1062))+(((-1.0)*x1057*x1058))+(((-1.0)*r21*x1057*x1060)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r11*x1060))+(((-1.0)*r20*x1059*x1062))+(((-1.0)*x1058*x1062))+((cj1*r10*x1059))+((cj1*x1061))+(((-1.0)*r21*x1060*x1062)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r10*x1059*x1062))+(((-1.0)*r20*x1057*x1059))+(((-1.0)*r11*x1060*x1062))+(((-1.0)*x1061*x1062))+(((-1.0)*x1057*x1058))+(((-1.0)*r21*x1057*x1060))))+IKsqr((((cj1*r11*x1060))+(((-1.0)*r20*x1059*x1062))+(((-1.0)*x1058*x1062))+((cj1*r10*x1059))+((cj1*x1061))+(((-1.0)*r21*x1060*x1062))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*r10*x1059*x1062))+(((-1.0)*r20*x1057*x1059))+(((-1.0)*r11*x1060*x1062))+(((-1.0)*x1061*x1062))+(((-1.0)*x1057*x1058))+(((-1.0)*r21*x1057*x1060))), (((cj1*r11*x1060))+(((-1.0)*r20*x1059*x1062))+(((-1.0)*x1058*x1062))+((cj1*r10*x1059))+((cj1*x1061))+(((-1.0)*r21*x1060*x1062))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1063=IKcos(j2);
IkReal x1064=IKsin(j2);
IkReal x1065=(cj5*r10);
IkReal x1066=((1.0)*sj3);
IkReal x1067=(cj5*r20);
IkReal x1068=(r11*sj5);
IkReal x1069=(r21*sj5);
IkReal x1070=((1.0)*cj4);
IkReal x1071=((1.0)*sj1);
IkReal x1072=(cj3*sj4);
IkReal x1073=(cj3*sj5);
IkReal x1074=(cj3*cj5);
IkReal x1075=(cj1*x1063);
IkReal x1076=(cj1*x1064);
IkReal x1077=((1.0)*sj4*sj5);
IkReal x1078=(sj1*x1063);
IkReal x1079=((1.0)*cj5*sj4);
IkReal x1080=(sj1*x1064);
IkReal x1081=(x1064*x1071);
evalcond[0]=(x1075+(((-1.0)*r12*x1070))+(((-1.0)*r11*x1079))+(((-1.0)*r10*x1077))+(((-1.0)*x1081)));
evalcond[1]=((((-1.0)*x1063*x1071))+(((-1.0)*r20*x1077))+(((-1.0)*r21*x1079))+(((-1.0)*r22*x1070))+(((-1.0)*x1076)));
evalcond[2]=(x1078+x1076+((r12*x1072))+((sj3*x1068))+(((-1.0)*r10*x1070*x1073))+(((-1.0)*x1065*x1066))+(((-1.0)*r11*x1070*x1074)));
evalcond[3]=(x1075+(((-1.0)*r21*x1070*x1074))+((sj3*x1069))+(((-1.0)*x1066*x1067))+((r22*x1072))+(((-1.0)*x1081))+(((-1.0)*r20*x1070*x1073)));
evalcond[4]=((((-0.0075)*x1067))+(((-0.3125)*sj1))+(((-0.0675)*x1080))+(((-1.0)*pz))+(((0.0075)*x1069))+(((-0.38609)*x1078))+(((-0.38609)*x1076))+(((0.0675)*x1075)));
evalcond[5]=((((-0.0075)*x1065))+(((0.3125)*cj1))+(((-1.0)*py))+(((0.0075)*x1068))+(((0.0675)*x1076))+(((0.0675)*x1078))+(((0.38609)*x1075))+(((-0.38609)*x1080)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j0)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1082=((1.0)*r20);
IkReal x1083=(((cj5*r11*sj4))+((r10*sj4*sj5))+((cj4*r12)));
j3eval[0]=x1083;
j3eval[1]=IKsign(x1083);
j3eval[2]=((IKabs((((r21*sj5))+(((-1.0)*cj5*x1082)))))+(IKabs((((r22*sj4))+(((-1.0)*cj4*sj5*x1082))+(((-1.0)*cj4*cj5*r21))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1084=((1.0)*cj5);
IkReal x1085=((1.0)*sj5);
IkReal x1086=((((-1.0)*r20*sj4*x1085))+(((-1.0)*cj4*r22))+(((-1.0)*r21*sj4*x1084)));
j3eval[0]=x1086;
j3eval[1]=IKsign(x1086);
j3eval[2]=((IKabs(((((-1.0)*r10*x1084))+((r11*sj5)))))+(IKabs(((((-1.0)*cj4*r10*x1085))+((r12*sj4))+(((-1.0)*cj4*r11*x1084))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1087=cj4*cj4;
IkReal x1088=r00*r00;
IkReal x1089=cj5*cj5;
IkReal x1090=r01*r01;
IkReal x1091=r02*r02;
IkReal x1092=(r00*sj5);
IkReal x1093=((1.0)*r01);
IkReal x1094=((2.0)*cj5*r01);
IkReal x1095=(cj4*r02*sj4);
IkReal x1096=((1.0)*x1089);
IkReal x1097=(x1087*x1088);
IkReal x1098=(x1097+x1090+x1091+(((-1.0)*x1090*x1096))+(((-1.0)*x1096*x1097))+(((-1.0)*x1094*x1095))+(((-1.0)*x1092*x1094))+((x1087*x1089*x1090))+((x1087*x1092*x1094))+(((-2.0)*x1092*x1095))+((x1088*x1089))+(((-1.0)*x1087*x1091)));
j3eval[0]=x1098;
j3eval[1]=((IKabs((((r02*sj4))+(((-1.0)*cj4*cj5*x1093))+(((-1.0)*cj4*x1092)))))+(IKabs(((((-1.0)*sj5*x1093))+((cj5*r00))))));
j3eval[2]=IKsign(x1098);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2, j3]

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1099=cj4*cj4;
IkReal x1100=r00*r00;
IkReal x1101=cj5*cj5;
IkReal x1102=r01*r01;
IkReal x1103=r02*r02;
IkReal x1104=(r00*sj5);
IkReal x1105=((1.0)*r01);
IkReal x1106=((2.0)*cj5*r01);
IkReal x1107=(cj4*r02*sj4);
IkReal x1108=((1.0)*x1101);
IkReal x1109=(x1099*x1100);
CheckValue<IkReal> x1110=IKPowWithIntegerCheck(IKsign((x1102+x1103+x1109+((x1099*x1101*x1102))+(((-2.0)*x1104*x1107))+((x1099*x1104*x1106))+(((-1.0)*x1108*x1109))+(((-1.0)*x1106*x1107))+(((-1.0)*x1104*x1106))+((x1100*x1101))+(((-1.0)*x1099*x1103))+(((-1.0)*x1102*x1108)))),-1);
if(!x1110.valid){
continue;
}
CheckValue<IkReal> x1111 = IKatan2WithCheck(IkReal(((((-1.0)*cj4*x1104))+(((-1.0)*cj4*cj5*x1105))+((r02*sj4)))),IkReal(((((-1.0)*sj5*x1105))+((cj5*r00)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1111.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1110.value)))+(x1111.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1112=IKsin(j3);
IkReal x1113=IKcos(j3);
IkReal x1114=(cj4*cj5);
IkReal x1115=(cj5*r00);
IkReal x1116=(r02*sj4);
IkReal x1117=((1.0)*x1113);
IkReal x1118=(r01*x1112);
IkReal x1119=((1.0)*x1112);
IkReal x1120=(sj5*x1113);
IkReal x1121=(cj4*sj5*x1112);
evalcond[0]=(((r21*x1112*x1114))+((r21*x1120))+(((-1.0)*r22*sj4*x1119))+(((-1.0)*cj5*r20*x1117))+((r20*x1121)));
evalcond[1]=((((-1.0)*cj5*r10*x1117))+((r10*x1121))+((r11*x1112*x1114))+((r11*x1120))+(((-1.0)*r12*sj4*x1119)));
evalcond[2]=((1.0)+((x1114*x1118))+((r00*x1121))+((r01*x1120))+(((-1.0)*x1116*x1119))+(((-1.0)*x1115*x1117)));
evalcond[3]=(((x1113*x1116))+(((-1.0)*r01*x1114*x1117))+(((-1.0)*cj4*r00*sj5*x1117))+((sj5*x1118))+(((-1.0)*x1115*x1119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1122=((12.0)*pz);
IkReal x1123=((4.0)*pz);
IkReal x1124=(r21*sj5);
IkReal x1125=((0.27)*cj4);
IkReal x1126=(r20*sj5);
IkReal x1127=((1.54436)*sj4);
IkReal x1128=((0.81)*cj4);
IkReal x1129=(cj5*r21);
IkReal x1130=((0.81)*sj3);
IkReal x1131=(cj5*r20);
IkReal x1132=((0.27)*sj3);
IkReal x1133=((0.27)*sj4);
IkReal x1134=(r10*sj5);
IkReal x1135=((4.63308)*sj4);
IkReal x1136=(cj3*r22);
IkReal x1137=(cj4*r22);
IkReal x1138=((0.81)*sj4);
IkReal x1139=((0.09)*x1131);
IkReal x1140=((4.63308)*x1137);
IkReal x1141=((0.09)*x1124);
IkReal x1142=((0.03)*x1131);
IkReal x1143=((0.03)*x1124);
IkReal x1144=((1.54436)*x1137);
IkReal x1145=(cj5*r11*sj4);
IkReal x1146=(x1126*x1135);
IkReal x1147=(x1129*x1135);
IkReal x1148=(x1127*x1129);
IkReal x1149=(x1126*x1127);
IkReal x1150=(x1142+x1123);
IkReal x1151=(x1122+x1139);
IkReal x1152=(x1143+x1144+x1148+x1149);
IkReal x1153=(x1140+x1141+x1146+x1147);
j1eval[0]=((10.0)+(IKabs((x1153+((x1130*x1131))+(((-1.0)*x1151))+((cj3*x1126*x1128))+((cj3*x1128*x1129))+(((-1.0)*x1136*x1138))+(((-1.0)*x1124*x1130)))))+(((0.5)*(IKabs((x1152+(((-1.0)*x1150))+((x1131*x1132))+((cj3*x1125*x1126))+((cj3*x1125*x1129))+(((-1.0)*x1124*x1132))+(((-1.0)*x1133*x1136)))))))+(IKabs((x1151+(((-1.0)*x1153))+((cj5*r11*x1138))+((x1134*x1138))+((r12*x1128)))))+(((0.5)*(IKabs((x1150+(((-1.0)*x1152))+((cj5*r11*x1133))+((r12*x1125))+((x1133*x1134))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1154=(r21*sj5);
IkReal x1155=(cj4*r12);
IkReal x1156=(cj4*r22);
IkReal x1157=(cj5*sj4);
IkReal x1158=(cj5*r20);
IkReal x1159=(r20*sj4*sj5);
IkReal x1160=(r10*sj4*sj5);
IkReal x1161=((((-4.63308)*x1156))+(((-4.63308)*x1159))+(((12.0)*pz))+(((0.81)*x1155))+(((-0.09)*x1154))+(((0.81)*x1160))+(((-4.63308)*r21*x1157))+(((0.81)*r11*x1157))+(((0.09)*x1158)));
IkReal x1162=((((0.27)*x1155))+(((4.0)*pz))+(((-1.54436)*x1159))+(((-1.54436)*x1156))+(((0.03)*x1158))+(((-0.03)*x1154))+(((0.27)*r11*x1157))+(((0.27)*x1160))+(((-1.54436)*r21*x1157)));
op[0]=x1162;
op[1]=2.5;
op[2]=x1161;
op[3]=5.0;
op[4]=x1161;
op[5]=2.5;
op[6]=x1162;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1163=((4.0)*pz);
IkReal x1164=(r21*sj5);
IkReal x1165=(r20*sj5);
IkReal x1166=(cj3*cj4);
IkReal x1167=((1.54436)*sj4);
IkReal x1168=((0.27)*cj5);
IkReal x1169=((0.81)*sj3);
IkReal x1170=((4.63308)*sj4);
IkReal x1171=(cj5*r21);
IkReal x1172=(cj4*r22);
IkReal x1173=(cj5*r20);
IkReal x1174=((0.03)*x1164);
IkReal x1175=((1.54436)*x1172);
IkReal x1176=((0.03)*x1173);
IkReal x1177=(cj3*r22*sj4);
IkReal x1178=(x1167*x1171);
IkReal x1179=(x1165*x1167);
IkReal x1180=(r20*sj3*x1168);
IkReal x1181=((0.27)*sj3*x1164);
IkReal x1182=((0.27)*x1177);
IkReal x1183=((0.27)*x1165*x1166);
IkReal x1184=(r21*x1166*x1168);
IkReal x1185=(x1182+x1181+x1163+x1176);
IkReal x1186=(x1184+x1183+x1180+x1175+x1174+x1179+x1178);
IkReal x1187=((((-12.0)*pz))+((x1165*x1170))+(((0.09)*x1164))+(((4.63308)*x1172))+(((-0.09)*x1173))+(((-0.81)*x1177))+(((0.81)*x1165*x1166))+(((0.81)*x1166*x1171))+(((-1.0)*x1164*x1169))+((x1170*x1171))+((x1169*x1173)));
j1evalpoly[0]=(x1186+(((-2.5)*htj1))+(((-2.5)*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*x1185))+((x1187*(htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1186+(((-1.0)*x1185))))))+(((-5.0)*(htj1*htj1*htj1)))+((x1187*(htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1188=((1.0)*cj1);
IkReal x1189=(cj4*r22);
IkReal x1190=(cj4*r12);
IkReal x1191=((1.0)*sj1);
IkReal x1192=(r20*sj4*sj5);
IkReal x1193=(cj5*r21*sj4);
IkReal x1194=(cj5*r11*sj4);
IkReal x1195=(r10*sj4*sj5);
if( IKabs(((((-1.0)*x1188*x1189))+(((-1.0)*x1188*x1193))+(((-1.0)*x1188*x1192))+((sj1*x1194))+((sj1*x1195))+((sj1*x1190)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1191*x1192))+(((-1.0)*x1191*x1193))+(((-1.0)*x1189*x1191))+(((-1.0)*x1188*x1195))+(((-1.0)*x1188*x1194))+(((-1.0)*x1188*x1190)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1188*x1189))+(((-1.0)*x1188*x1193))+(((-1.0)*x1188*x1192))+((sj1*x1194))+((sj1*x1195))+((sj1*x1190))))+IKsqr(((((-1.0)*x1191*x1192))+(((-1.0)*x1191*x1193))+(((-1.0)*x1189*x1191))+(((-1.0)*x1188*x1195))+(((-1.0)*x1188*x1194))+(((-1.0)*x1188*x1190))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1188*x1189))+(((-1.0)*x1188*x1193))+(((-1.0)*x1188*x1192))+((sj1*x1194))+((sj1*x1195))+((sj1*x1190))), ((((-1.0)*x1191*x1192))+(((-1.0)*x1191*x1193))+(((-1.0)*x1189*x1191))+(((-1.0)*x1188*x1195))+(((-1.0)*x1188*x1194))+(((-1.0)*x1188*x1190))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1196=IKcos(j2);
IkReal x1197=IKsin(j2);
IkReal x1198=(cj5*r10);
IkReal x1199=((1.0)*sj3);
IkReal x1200=(cj5*r20);
IkReal x1201=(r11*sj5);
IkReal x1202=(r21*sj5);
IkReal x1203=((1.0)*cj4);
IkReal x1204=((1.0)*sj1);
IkReal x1205=(cj3*sj4);
IkReal x1206=(cj3*sj5);
IkReal x1207=(cj5*r21);
IkReal x1208=((1.0)*sj4);
IkReal x1209=(cj5*r11);
IkReal x1210=(cj1*x1196);
IkReal x1211=(sj5*x1208);
IkReal x1212=(sj1*x1196);
IkReal x1213=(cj1*x1197);
IkReal x1214=(sj1*x1197);
IkReal x1215=(x1196*x1204);
IkReal x1216=((1.0)*x1213);
IkReal x1217=(x1216+x1215);
evalcond[0]=(x1214+(((-1.0)*r10*x1211))+(((-1.0)*r12*x1203))+(((-1.0)*x1208*x1209))+(((-1.0)*x1210)));
evalcond[1]=((((-1.0)*r22*x1203))+(((-1.0)*r20*x1211))+(((-1.0)*x1217))+(((-1.0)*x1207*x1208)));
evalcond[2]=((((-1.0)*x1199*x1200))+x1210+(((-1.0)*cj3*x1203*x1207))+((sj3*x1202))+(((-1.0)*x1197*x1204))+(((-1.0)*r20*x1203*x1206))+((r22*x1205)));
evalcond[3]=((((-1.0)*r10*x1203*x1206))+(((-1.0)*x1198*x1199))+(((-1.0)*cj3*x1203*x1209))+((r12*x1205))+((sj3*x1201))+(((-1.0)*x1217)));
evalcond[4]=((((0.0675)*x1210))+(((-0.3125)*sj1))+(((-0.0675)*x1214))+(((-1.0)*pz))+(((0.0075)*x1202))+(((-0.38609)*x1212))+(((-0.38609)*x1213))+(((-0.0075)*x1200)));
evalcond[5]=((((-0.0075)*x1198))+(((-0.0675)*x1213))+(((-0.0675)*x1212))+(((-1.0)*py))+(((0.0075)*x1201))+(((-0.38609)*x1210))+(((0.38609)*x1214))+(((-0.3125)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1218=((1.0)*cj5);
IkReal x1219=((1.0)*sj5);
CheckValue<IkReal> x1220 = IKatan2WithCheck(IkReal((((r11*sj5))+(((-1.0)*r10*x1218)))),IkReal(((((-1.0)*cj4*r11*x1218))+((r12*sj4))+(((-1.0)*cj4*r10*x1219)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1220.valid){
continue;
}
CheckValue<IkReal> x1221=IKPowWithIntegerCheck(IKsign(((((-1.0)*r20*sj4*x1219))+(((-1.0)*r21*sj4*x1218))+(((-1.0)*cj4*r22)))),-1);
if(!x1221.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1220.value)+(((1.5707963267949)*(x1221.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1222=IKsin(j3);
IkReal x1223=IKcos(j3);
IkReal x1224=(cj4*cj5);
IkReal x1225=(cj5*r00);
IkReal x1226=(r02*sj4);
IkReal x1227=((1.0)*x1223);
IkReal x1228=(r01*x1222);
IkReal x1229=((1.0)*x1222);
IkReal x1230=(sj5*x1223);
IkReal x1231=(cj4*sj5*x1222);
evalcond[0]=((((-1.0)*r22*sj4*x1229))+((r20*x1231))+(((-1.0)*cj5*r20*x1227))+((r21*x1222*x1224))+((r21*x1230)));
evalcond[1]=((((-1.0)*cj5*r10*x1227))+((r10*x1231))+((r11*x1230))+(((-1.0)*r12*sj4*x1229))+((r11*x1222*x1224)));
evalcond[2]=((1.0)+((r00*x1231))+(((-1.0)*x1225*x1227))+((r01*x1230))+((x1224*x1228))+(((-1.0)*x1226*x1229)));
evalcond[3]=((((-1.0)*cj4*r00*sj5*x1227))+(((-1.0)*x1225*x1229))+((x1223*x1226))+((sj5*x1228))+(((-1.0)*r01*x1224*x1227)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1232=((12.0)*pz);
IkReal x1233=((4.0)*pz);
IkReal x1234=(r21*sj5);
IkReal x1235=((0.27)*cj4);
IkReal x1236=(r20*sj5);
IkReal x1237=((1.54436)*sj4);
IkReal x1238=((0.81)*cj4);
IkReal x1239=(cj5*r21);
IkReal x1240=((0.81)*sj3);
IkReal x1241=(cj5*r20);
IkReal x1242=((0.27)*sj3);
IkReal x1243=((0.27)*sj4);
IkReal x1244=(r10*sj5);
IkReal x1245=((4.63308)*sj4);
IkReal x1246=(cj3*r22);
IkReal x1247=(cj4*r22);
IkReal x1248=((0.81)*sj4);
IkReal x1249=((0.09)*x1241);
IkReal x1250=((4.63308)*x1247);
IkReal x1251=((0.09)*x1234);
IkReal x1252=((0.03)*x1241);
IkReal x1253=((0.03)*x1234);
IkReal x1254=((1.54436)*x1247);
IkReal x1255=(cj5*r11*sj4);
IkReal x1256=(x1236*x1245);
IkReal x1257=(x1239*x1245);
IkReal x1258=(x1237*x1239);
IkReal x1259=(x1236*x1237);
IkReal x1260=(x1252+x1233);
IkReal x1261=(x1249+x1232);
IkReal x1262=(x1254+x1253+x1258+x1259);
IkReal x1263=(x1256+x1257+x1250+x1251);
j1eval[0]=((10.0)+(IKabs((x1263+((cj3*x1236*x1238))+((x1240*x1241))+((cj3*x1238*x1239))+(((-1.0)*x1246*x1248))+(((-1.0)*x1234*x1240))+(((-1.0)*x1261)))))+(((0.5)*(IKabs((x1262+(((-1.0)*x1243*x1246))+((cj3*x1235*x1236))+((cj3*x1235*x1239))+((x1241*x1242))+(((-1.0)*x1234*x1242))+(((-1.0)*x1260)))))))+(IKabs((x1261+((x1244*x1248))+((cj5*r11*x1248))+(((-1.0)*x1263))+((r12*x1238)))))+(((0.5)*(IKabs((x1260+((cj5*r11*x1243))+((x1243*x1244))+(((-1.0)*x1262))+((r12*x1235))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1264=(r21*sj5);
IkReal x1265=(cj4*r12);
IkReal x1266=(cj4*r22);
IkReal x1267=(cj5*sj4);
IkReal x1268=(cj5*r20);
IkReal x1269=(r20*sj4*sj5);
IkReal x1270=(r10*sj4*sj5);
IkReal x1271=((((-4.63308)*r21*x1267))+(((12.0)*pz))+(((-0.09)*x1264))+(((0.81)*r11*x1267))+(((-4.63308)*x1266))+(((-4.63308)*x1269))+(((0.09)*x1268))+(((0.81)*x1270))+(((0.81)*x1265)));
IkReal x1272=((((-1.54436)*r21*x1267))+(((0.27)*r11*x1267))+(((4.0)*pz))+(((-1.54436)*x1269))+(((-1.54436)*x1266))+(((0.27)*x1265))+(((0.27)*x1270))+(((0.03)*x1268))+(((-0.03)*x1264)));
op[0]=x1272;
op[1]=2.5;
op[2]=x1271;
op[3]=5.0;
op[4]=x1271;
op[5]=2.5;
op[6]=x1272;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1273=((4.0)*pz);
IkReal x1274=(r21*sj5);
IkReal x1275=(r20*sj5);
IkReal x1276=(cj3*cj4);
IkReal x1277=((1.54436)*sj4);
IkReal x1278=((0.27)*cj5);
IkReal x1279=((0.81)*sj3);
IkReal x1280=((4.63308)*sj4);
IkReal x1281=(cj5*r21);
IkReal x1282=(cj4*r22);
IkReal x1283=(cj5*r20);
IkReal x1284=((0.03)*x1274);
IkReal x1285=((1.54436)*x1282);
IkReal x1286=((0.03)*x1283);
IkReal x1287=(cj3*r22*sj4);
IkReal x1288=(x1277*x1281);
IkReal x1289=(x1275*x1277);
IkReal x1290=(r20*sj3*x1278);
IkReal x1291=((0.27)*sj3*x1274);
IkReal x1292=((0.27)*x1287);
IkReal x1293=((0.27)*x1275*x1276);
IkReal x1294=(r21*x1276*x1278);
IkReal x1295=(x1273+x1286+x1292+x1291);
IkReal x1296=(x1285+x1284+x1289+x1288+x1293+x1290+x1294);
IkReal x1297=((((-0.09)*x1283))+((x1279*x1283))+(((-12.0)*pz))+(((0.81)*x1276*x1281))+((x1275*x1280))+(((0.09)*x1274))+(((-1.0)*x1274*x1279))+((x1280*x1281))+(((-0.81)*x1287))+(((0.81)*x1275*x1276))+(((4.63308)*x1282)));
j1evalpoly[0]=(x1296+(((-1.0)*x1295))+(((-2.5)*htj1))+(((-2.5)*(htj1*htj1*htj1*htj1*htj1)))+((x1297*(htj1*htj1*htj1*htj1)))+((x1297*(htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1296+(((-1.0)*x1295))))))+(((-5.0)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1298=((1.0)*cj1);
IkReal x1299=(cj4*r22);
IkReal x1300=(cj4*r12);
IkReal x1301=((1.0)*sj1);
IkReal x1302=(r20*sj4*sj5);
IkReal x1303=(cj5*r21*sj4);
IkReal x1304=(cj5*r11*sj4);
IkReal x1305=(r10*sj4*sj5);
if( IKabs(((((-1.0)*x1298*x1299))+(((-1.0)*x1298*x1302))+(((-1.0)*x1298*x1303))+((sj1*x1300))+((sj1*x1305))+((sj1*x1304)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1299*x1301))+(((-1.0)*x1298*x1304))+(((-1.0)*x1298*x1305))+(((-1.0)*x1298*x1300))+(((-1.0)*x1301*x1303))+(((-1.0)*x1301*x1302)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1298*x1299))+(((-1.0)*x1298*x1302))+(((-1.0)*x1298*x1303))+((sj1*x1300))+((sj1*x1305))+((sj1*x1304))))+IKsqr(((((-1.0)*x1299*x1301))+(((-1.0)*x1298*x1304))+(((-1.0)*x1298*x1305))+(((-1.0)*x1298*x1300))+(((-1.0)*x1301*x1303))+(((-1.0)*x1301*x1302))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1298*x1299))+(((-1.0)*x1298*x1302))+(((-1.0)*x1298*x1303))+((sj1*x1300))+((sj1*x1305))+((sj1*x1304))), ((((-1.0)*x1299*x1301))+(((-1.0)*x1298*x1304))+(((-1.0)*x1298*x1305))+(((-1.0)*x1298*x1300))+(((-1.0)*x1301*x1303))+(((-1.0)*x1301*x1302))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1306=IKcos(j2);
IkReal x1307=IKsin(j2);
IkReal x1308=(cj5*r10);
IkReal x1309=((1.0)*sj3);
IkReal x1310=(cj5*r20);
IkReal x1311=(r11*sj5);
IkReal x1312=(r21*sj5);
IkReal x1313=((1.0)*cj4);
IkReal x1314=((1.0)*sj1);
IkReal x1315=(cj3*sj4);
IkReal x1316=(cj3*sj5);
IkReal x1317=(cj5*r21);
IkReal x1318=((1.0)*sj4);
IkReal x1319=(cj5*r11);
IkReal x1320=(cj1*x1306);
IkReal x1321=(sj5*x1318);
IkReal x1322=(sj1*x1306);
IkReal x1323=(cj1*x1307);
IkReal x1324=(sj1*x1307);
IkReal x1325=(x1306*x1314);
IkReal x1326=((1.0)*x1323);
IkReal x1327=(x1326+x1325);
evalcond[0]=(x1324+(((-1.0)*x1318*x1319))+(((-1.0)*r12*x1313))+(((-1.0)*x1320))+(((-1.0)*r10*x1321)));
evalcond[1]=((((-1.0)*x1317*x1318))+(((-1.0)*r22*x1313))+(((-1.0)*x1327))+(((-1.0)*r20*x1321)));
evalcond[2]=(x1320+((sj3*x1312))+(((-1.0)*cj3*x1313*x1317))+(((-1.0)*x1307*x1314))+((r22*x1315))+(((-1.0)*r20*x1313*x1316))+(((-1.0)*x1309*x1310)));
evalcond[3]=(((sj3*x1311))+(((-1.0)*cj3*x1313*x1319))+(((-1.0)*x1327))+(((-1.0)*x1308*x1309))+(((-1.0)*r10*x1313*x1316))+((r12*x1315)));
evalcond[4]=((((-0.38609)*x1322))+(((-0.38609)*x1323))+(((-0.0075)*x1310))+(((0.0675)*x1320))+(((-0.3125)*sj1))+(((0.0075)*x1312))+(((-1.0)*pz))+(((-0.0675)*x1324)));
evalcond[5]=((((-0.38609)*x1320))+(((-0.0075)*x1308))+(((0.0075)*x1311))+(((0.38609)*x1324))+(((-1.0)*py))+(((-0.0675)*x1323))+(((-0.0675)*x1322))+(((-0.3125)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1328=((1.0)*r20);
CheckValue<IkReal> x1329=IKPowWithIntegerCheck(IKsign((((cj5*r11*sj4))+((r10*sj4*sj5))+((cj4*r12)))),-1);
if(!x1329.valid){
continue;
}
CheckValue<IkReal> x1330 = IKatan2WithCheck(IkReal((((r21*sj5))+(((-1.0)*cj5*x1328)))),IkReal((((r22*sj4))+(((-1.0)*cj4*cj5*r21))+(((-1.0)*cj4*sj5*x1328)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1330.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1329.value)))+(x1330.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[4];
IkReal x1331=IKsin(j3);
IkReal x1332=IKcos(j3);
IkReal x1333=(cj4*cj5);
IkReal x1334=(cj5*r00);
IkReal x1335=(r02*sj4);
IkReal x1336=((1.0)*x1332);
IkReal x1337=(r01*x1331);
IkReal x1338=((1.0)*x1331);
IkReal x1339=(sj5*x1332);
IkReal x1340=(cj4*sj5*x1331);
evalcond[0]=(((r21*x1339))+((r21*x1331*x1333))+((r20*x1340))+(((-1.0)*r22*sj4*x1338))+(((-1.0)*cj5*r20*x1336)));
evalcond[1]=((((-1.0)*cj5*r10*x1336))+((r11*x1339))+(((-1.0)*r12*sj4*x1338))+((r11*x1331*x1333))+((r10*x1340)));
evalcond[2]=((1.0)+(((-1.0)*x1335*x1338))+(((-1.0)*x1334*x1336))+((r01*x1339))+((r00*x1340))+((x1333*x1337)));
evalcond[3]=((((-1.0)*r01*x1333*x1336))+(((-1.0)*x1334*x1338))+((sj5*x1337))+(((-1.0)*cj4*r00*sj5*x1336))+((x1332*x1335)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
sj0=-1.0;
cj0=0;
j0=-1.5707963267949;
IkReal x1341=((12.0)*pz);
IkReal x1342=((4.0)*pz);
IkReal x1343=(r21*sj5);
IkReal x1344=((0.27)*cj4);
IkReal x1345=(r20*sj5);
IkReal x1346=((1.54436)*sj4);
IkReal x1347=((0.81)*cj4);
IkReal x1348=(cj5*r21);
IkReal x1349=((0.81)*sj3);
IkReal x1350=(cj5*r20);
IkReal x1351=((0.27)*sj3);
IkReal x1352=((0.27)*sj4);
IkReal x1353=(r10*sj5);
IkReal x1354=((4.63308)*sj4);
IkReal x1355=(cj3*r22);
IkReal x1356=(cj4*r22);
IkReal x1357=((0.81)*sj4);
IkReal x1358=((0.09)*x1350);
IkReal x1359=((4.63308)*x1356);
IkReal x1360=((0.09)*x1343);
IkReal x1361=((0.03)*x1350);
IkReal x1362=((0.03)*x1343);
IkReal x1363=((1.54436)*x1356);
IkReal x1364=(cj5*r11*sj4);
IkReal x1365=(x1345*x1354);
IkReal x1366=(x1348*x1354);
IkReal x1367=(x1346*x1348);
IkReal x1368=(x1345*x1346);
IkReal x1369=(x1342+x1361);
IkReal x1370=(x1341+x1358);
IkReal x1371=(x1367+x1362+x1363+x1368);
IkReal x1372=(x1359+x1366+x1365+x1360);
j1eval[0]=((10.0)+(IKabs((x1372+((cj3*x1347*x1348))+(((-1.0)*x1355*x1357))+(((-1.0)*x1370))+((x1349*x1350))+((cj3*x1345*x1347))+(((-1.0)*x1343*x1349)))))+(((0.5)*(IKabs((((cj5*r11*x1352))+x1369+(((-1.0)*x1371))+((r12*x1344))+((x1352*x1353)))))))+(IKabs((((cj5*r11*x1357))+x1370+(((-1.0)*x1372))+((r12*x1347))+((x1353*x1357)))))+(((0.5)*(IKabs((x1371+(((-1.0)*x1352*x1355))+((cj3*x1344*x1345))+((cj3*x1344*x1348))+((x1350*x1351))+(((-1.0)*x1343*x1351))+(((-1.0)*x1369))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1373=(r21*sj5);
IkReal x1374=(cj4*r12);
IkReal x1375=(cj4*r22);
IkReal x1376=(cj5*sj4);
IkReal x1377=(cj5*r20);
IkReal x1378=(r20*sj4*sj5);
IkReal x1379=(r10*sj4*sj5);
IkReal x1380=((((12.0)*pz))+(((0.09)*x1377))+(((-4.63308)*r21*x1376))+(((0.81)*x1379))+(((0.81)*x1374))+(((-0.09)*x1373))+(((-4.63308)*x1378))+(((-4.63308)*x1375))+(((0.81)*r11*x1376)));
IkReal x1381=((((0.27)*x1374))+(((0.27)*x1379))+(((0.27)*r11*x1376))+(((4.0)*pz))+(((-1.54436)*x1375))+(((-1.54436)*x1378))+(((0.03)*x1377))+(((-1.54436)*r21*x1376))+(((-0.03)*x1373)));
op[0]=x1381;
op[1]=2.5;
op[2]=x1380;
op[3]=5.0;
op[4]=x1380;
op[5]=2.5;
op[6]=x1381;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1382=((4.0)*pz);
IkReal x1383=(r21*sj5);
IkReal x1384=(r20*sj5);
IkReal x1385=(cj3*cj4);
IkReal x1386=((1.54436)*sj4);
IkReal x1387=((0.27)*cj5);
IkReal x1388=((0.81)*sj3);
IkReal x1389=((4.63308)*sj4);
IkReal x1390=(cj5*r21);
IkReal x1391=(cj4*r22);
IkReal x1392=(cj5*r20);
IkReal x1393=((0.03)*x1383);
IkReal x1394=((1.54436)*x1391);
IkReal x1395=((0.03)*x1392);
IkReal x1396=(cj3*r22*sj4);
IkReal x1397=(x1386*x1390);
IkReal x1398=(x1384*x1386);
IkReal x1399=(r20*sj3*x1387);
IkReal x1400=((0.27)*sj3*x1383);
IkReal x1401=((0.27)*x1396);
IkReal x1402=((0.27)*x1384*x1385);
IkReal x1403=(r21*x1385*x1387);
IkReal x1404=(x1382+x1395+x1401+x1400);
IkReal x1405=(x1399+x1398+x1397+x1394+x1393+x1403+x1402);
IkReal x1406=(((x1388*x1392))+(((-1.0)*x1383*x1388))+(((-0.09)*x1392))+(((-0.81)*x1396))+(((-12.0)*pz))+(((4.63308)*x1391))+(((0.81)*x1384*x1385))+(((0.81)*x1385*x1390))+((x1389*x1390))+((x1384*x1389))+(((0.09)*x1383)));
j1evalpoly[0]=((((-2.5)*htj1))+(((-2.5)*(htj1*htj1*htj1*htj1*htj1)))+((x1406*(htj1*htj1*htj1*htj1)))+(((-1.0)*x1404))+((x1406*(htj1*htj1)))+x1405+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1404))+x1405))))+(((-5.0)*(htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1407=((1.0)*cj1);
IkReal x1408=(cj4*r22);
IkReal x1409=(cj4*r12);
IkReal x1410=((1.0)*sj1);
IkReal x1411=(r20*sj4*sj5);
IkReal x1412=(cj5*r21*sj4);
IkReal x1413=(cj5*r11*sj4);
IkReal x1414=(r10*sj4*sj5);
if( IKabs(((((-1.0)*x1407*x1411))+(((-1.0)*x1407*x1412))+((sj1*x1409))+(((-1.0)*x1407*x1408))+((sj1*x1414))+((sj1*x1413)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1407*x1414))+(((-1.0)*x1407*x1413))+(((-1.0)*x1408*x1410))+(((-1.0)*x1410*x1411))+(((-1.0)*x1410*x1412))+(((-1.0)*x1407*x1409)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1407*x1411))+(((-1.0)*x1407*x1412))+((sj1*x1409))+(((-1.0)*x1407*x1408))+((sj1*x1414))+((sj1*x1413))))+IKsqr(((((-1.0)*x1407*x1414))+(((-1.0)*x1407*x1413))+(((-1.0)*x1408*x1410))+(((-1.0)*x1410*x1411))+(((-1.0)*x1410*x1412))+(((-1.0)*x1407*x1409))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1407*x1411))+(((-1.0)*x1407*x1412))+((sj1*x1409))+(((-1.0)*x1407*x1408))+((sj1*x1414))+((sj1*x1413))), ((((-1.0)*x1407*x1414))+(((-1.0)*x1407*x1413))+(((-1.0)*x1408*x1410))+(((-1.0)*x1410*x1411))+(((-1.0)*x1410*x1412))+(((-1.0)*x1407*x1409))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x1415=IKcos(j2);
IkReal x1416=IKsin(j2);
IkReal x1417=(cj5*r10);
IkReal x1418=((1.0)*sj3);
IkReal x1419=(cj5*r20);
IkReal x1420=(r11*sj5);
IkReal x1421=(r21*sj5);
IkReal x1422=((1.0)*cj4);
IkReal x1423=((1.0)*sj1);
IkReal x1424=(cj3*sj4);
IkReal x1425=(cj3*sj5);
IkReal x1426=(cj5*r21);
IkReal x1427=((1.0)*sj4);
IkReal x1428=(cj5*r11);
IkReal x1429=(cj1*x1415);
IkReal x1430=(sj5*x1427);
IkReal x1431=(sj1*x1415);
IkReal x1432=(cj1*x1416);
IkReal x1433=(sj1*x1416);
IkReal x1434=(x1415*x1423);
IkReal x1435=((1.0)*x1432);
IkReal x1436=(x1434+x1435);
evalcond[0]=((((-1.0)*x1427*x1428))+(((-1.0)*r12*x1422))+(((-1.0)*x1429))+(((-1.0)*r10*x1430))+x1433);
evalcond[1]=((((-1.0)*x1426*x1427))+(((-1.0)*x1436))+(((-1.0)*r22*x1422))+(((-1.0)*r20*x1430)));
evalcond[2]=((((-1.0)*cj3*x1422*x1426))+(((-1.0)*x1416*x1423))+(((-1.0)*r20*x1422*x1425))+((r22*x1424))+(((-1.0)*x1418*x1419))+x1429+((sj3*x1421)));
evalcond[3]=((((-1.0)*cj3*x1422*x1428))+(((-1.0)*r10*x1422*x1425))+(((-1.0)*x1417*x1418))+(((-1.0)*x1436))+((r12*x1424))+((sj3*x1420)));
evalcond[4]=((((-0.38609)*x1432))+(((-0.38609)*x1431))+(((-0.0675)*x1433))+(((-0.3125)*sj1))+(((-0.0075)*x1419))+(((-1.0)*pz))+(((0.0075)*x1421))+(((0.0675)*x1429)));
evalcond[5]=((((-0.0675)*x1432))+(((-0.0675)*x1431))+(((-0.0075)*x1417))+(((-1.0)*py))+(((-0.38609)*x1429))+(((0.38609)*x1433))+(((0.0075)*x1420))+(((-0.3125)*cj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j2, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1437=((1.0)*cj5);
IkReal x1438=(cj4*sj0);
IkReal x1439=(cj0*r00);
IkReal x1440=(cj0*r01);
IkReal x1441=((1.0)*sj5);
CheckValue<IkReal> x1442=IKPowWithIntegerCheck(IKsign((((cj4*r22))+((cj5*r21*sj4))+((r20*sj4*sj5)))),-1);
if(!x1442.valid){
continue;
}
CheckValue<IkReal> x1443 = IKatan2WithCheck(IkReal(((((-1.0)*x1437*x1439))+((r11*sj0*sj5))+(((-1.0)*r10*sj0*x1437))+((sj5*x1440)))),IkReal(((((-1.0)*r11*x1437*x1438))+((r12*sj0*sj4))+(((-1.0)*cj4*x1439*x1441))+(((-1.0)*r10*x1438*x1441))+(((-1.0)*cj4*x1437*x1440))+((cj0*r02*sj4)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1443.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1442.value)))+(x1443.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1444=IKsin(j3);
IkReal x1445=IKcos(j3);
IkReal x1446=(sj5*x1445);
IkReal x1447=(cj4*cj5*x1444);
IkReal x1448=(cj4*sj5*x1444);
IkReal x1449=((1.0)*cj5*x1445);
IkReal x1450=((1.0)*sj4*x1444);
evalcond[0]=((((-1.0)*r20*x1449))+(((-1.0)*r22*x1450))+((r21*x1446))+((r21*x1447))+((r20*x1448)));
evalcond[1]=(((r10*x1448))+((r11*x1447))+((r11*x1446))+cj0+(((-1.0)*r10*x1449))+(((-1.0)*r12*x1450)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r00*x1449))+(((-1.0)*r02*x1450))+((r00*x1448))+((r01*x1447))+((r01*x1446)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1451=(cj4*r12);
IkReal x1452=(pz*sj0);
IkReal x1453=(sj0*sj5);
IkReal x1454=((0.03)*r21);
IkReal x1455=((4.63308)*sj4);
IkReal x1456=(cj5*sj0);
IkReal x1457=((0.09)*r21);
IkReal x1458=(cj0*sj5);
IkReal x1459=(cj4*r22);
IkReal x1460=(cj4*r02);
IkReal x1461=((1.54436)*cj0);
IkReal x1462=(r21*sj4);
IkReal x1463=(cj0*pz);
IkReal x1464=(cj0*cj5*r20);
IkReal x1465=(cj5*r11*sj4);
IkReal x1466=((0.27)*sj4*sj5);
IkReal x1467=((1.54436)*r20*sj4);
IkReal x1468=(cj5*r01*sj4);
IkReal x1469=((0.81)*sj4*sj5);
j1eval[0]=((((0.5)*(IKabs(((((-4.0)*x1463))+((x1454*x1458))+((x1459*x1461))+(((-0.03)*x1464))+((r00*x1466))+((x1458*x1467))+((cj5*x1461*x1462))+(((0.27)*x1468))+(((0.27)*x1460)))))))+(((5.0)*(IKabs(cj0))))+(IKabs(((((4.63308)*sj0*x1459))+(((-12.0)*x1452))+(((0.81)*x1451))+((r20*x1453*x1455))+(((0.81)*x1465))+(((-0.09)*r20*x1456))+((r10*x1469))+((r21*x1455*x1456))+((x1453*x1457)))))+(IKabs((((r00*x1469))+(((-12.0)*x1463))+(((0.81)*x1468))+(((0.81)*x1460))+(((4.63308)*cj0*x1459))+((cj0*cj5*r21*x1455))+(((-0.09)*x1464))+((r20*x1455*x1458))+((x1457*x1458)))))+(((5.0)*(IKabs(sj0))))+(((0.5)*(IKabs((((x1453*x1467))+(((1.54436)*sj0*x1459))+(((1.54436)*x1456*x1462))+(((-4.0)*x1452))+((r10*x1466))+(((0.27)*x1451))+(((0.27)*x1465))+(((-0.03)*r20*x1456))+((x1453*x1454))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1470=(cj5*sj4);
IkReal x1471=(cj0*sj5);
IkReal x1472=(r20*sj4);
IkReal x1473=(cj0*r21);
IkReal x1474=(cj4*r02);
IkReal x1475=(cj0*pz);
IkReal x1476=((-2.5)*cj0);
IkReal x1477=(cj0*cj4*r22);
IkReal x1478=(cj0*cj5*r20);
IkReal x1479=(r00*sj4*sj5);
IkReal x1480=((((-0.09)*x1478))+(((4.63308)*x1471*x1472))+(((4.63308)*x1477))+(((0.09)*r21*x1471))+(((0.81)*r01*x1470))+(((4.63308)*x1470*x1473))+(((-12.0)*x1475))+(((0.81)*x1474))+(((0.81)*x1479)));
IkReal x1481=((((0.27)*x1474))+(((0.27)*x1479))+(((1.54436)*x1471*x1472))+(((0.27)*r01*x1470))+(((-4.0)*x1475))+(((0.03)*r21*x1471))+(((-0.03)*x1478))+(((1.54436)*x1477))+(((1.54436)*x1470*x1473)));
op[0]=x1481;
op[1]=x1476;
op[2]=x1480;
op[3]=((-5.0)*cj0);
op[4]=x1480;
op[5]=x1476;
op[6]=x1481;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1482=(cj4*r12);
IkReal x1483=((2.5)*sj0);
IkReal x1484=(sj0*sj5);
IkReal x1485=(r20*sj4);
IkReal x1486=(cj5*sj0);
IkReal x1487=(r21*sj4);
IkReal x1488=(pz*sj0);
IkReal x1489=((0.27)*x1482);
IkReal x1490=((4.0)*x1488);
IkReal x1491=(cj5*r11*sj4);
IkReal x1492=(cj4*r22*sj0);
IkReal x1493=(r10*sj4*sj5);
IkReal x1494=((1.54436)*x1492);
IkReal x1495=((0.27)*x1491);
IkReal x1496=((0.27)*x1493);
IkReal x1497=((0.03)*r21*x1484);
IkReal x1498=((0.03)*r20*x1486);
IkReal x1499=((1.54436)*x1484*x1485);
IkReal x1500=((1.54436)*x1486*x1487);
IkReal x1501=(x1490+x1498);
IkReal x1502=(x1500+x1494+x1495+x1496+x1497+x1499+x1489);
IkReal x1503=((((4.63308)*x1492))+(((0.81)*x1482))+(((0.09)*r21*x1484))+(((4.63308)*x1486*x1487))+(((0.81)*x1493))+(((0.81)*x1491))+(((4.63308)*x1484*x1485))+(((-12.0)*x1488))+(((-0.09)*r20*x1486)));
j1evalpoly[0]=((((-1.0)*x1501))+((x1503*(htj1*htj1)))+(((-5.0)*sj0*(htj1*htj1*htj1)))+(((-1.0)*x1483*(htj1*htj1*htj1*htj1*htj1)))+((x1503*(htj1*htj1*htj1*htj1)))+x1502+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1501))+x1502))))+(((-1.0)*htj1*x1483)));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1504=((1.0)*cj1);
IkReal x1505=(cj4*r22);
IkReal x1506=(r20*sj5);
IkReal x1507=(sj1*sj4);
IkReal x1508=(cj3*r22);
IkReal x1509=(cj5*r21);
IkReal x1510=((1.0)*sj1);
IkReal x1511=(cj3*cj4);
IkReal x1512=(cj1*x1511);
IkReal x1513=(cj5*r20*sj3);
IkReal x1514=(r21*sj3*sj5);
if( IKabs(((((-1.0)*x1504*x1505))+(((-1.0)*x1506*x1510*x1511))+(((-1.0)*x1510*x1513))+((x1507*x1508))+(((-1.0)*x1509*x1510*x1511))+((sj1*x1514))+(((-1.0)*sj4*x1504*x1506))+(((-1.0)*sj4*x1504*x1509)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((x1509*x1512))+(((-1.0)*x1507*x1509))+(((-1.0)*x1504*x1514))+((x1506*x1512))+((cj1*x1513))+(((-1.0)*x1506*x1507))+(((-1.0)*x1505*x1510))+(((-1.0)*sj4*x1504*x1508)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1504*x1505))+(((-1.0)*x1506*x1510*x1511))+(((-1.0)*x1510*x1513))+((x1507*x1508))+(((-1.0)*x1509*x1510*x1511))+((sj1*x1514))+(((-1.0)*sj4*x1504*x1506))+(((-1.0)*sj4*x1504*x1509))))+IKsqr((((x1509*x1512))+(((-1.0)*x1507*x1509))+(((-1.0)*x1504*x1514))+((x1506*x1512))+((cj1*x1513))+(((-1.0)*x1506*x1507))+(((-1.0)*x1505*x1510))+(((-1.0)*sj4*x1504*x1508))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1504*x1505))+(((-1.0)*x1506*x1510*x1511))+(((-1.0)*x1510*x1513))+((x1507*x1508))+(((-1.0)*x1509*x1510*x1511))+((sj1*x1514))+(((-1.0)*sj4*x1504*x1506))+(((-1.0)*sj4*x1504*x1509))), (((x1509*x1512))+(((-1.0)*x1507*x1509))+(((-1.0)*x1504*x1514))+((x1506*x1512))+((cj1*x1513))+(((-1.0)*x1506*x1507))+(((-1.0)*x1505*x1510))+(((-1.0)*sj4*x1504*x1508))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1515=IKcos(j2);
IkReal x1516=IKsin(j2);
IkReal x1517=(cj3*sj4);
IkReal x1518=(r11*sj5);
IkReal x1519=(cj0*cj1);
IkReal x1520=((1.0)*cj4);
IkReal x1521=(cj5*r01);
IkReal x1522=(r21*sj5);
IkReal x1523=((0.38609)*cj0);
IkReal x1524=((1.0)*sj1);
IkReal x1525=(cj3*sj5);
IkReal x1526=((0.0075)*cj5);
IkReal x1527=(r01*sj5);
IkReal x1528=((1.0)*sj4);
IkReal x1529=(cj5*r21);
IkReal x1530=(cj5*r11);
IkReal x1531=(cj1*x1515);
IkReal x1532=((1.0)*cj5*sj3);
IkReal x1533=(sj5*x1528);
IkReal x1534=((0.0675)*x1516);
IkReal x1535=(sj1*x1515);
IkReal x1536=(cj1*x1516);
IkReal x1537=((0.0675)*x1535);
IkReal x1538=(sj0*sj1*x1516);
IkReal x1539=(sj0*x1536);
evalcond[0]=((((-1.0)*x1536))+(((-1.0)*x1515*x1524))+(((-1.0)*r22*x1520))+(((-1.0)*x1528*x1529))+(((-1.0)*r20*x1533)));
evalcond[1]=((((-1.0)*r00*x1533))+(((-1.0)*r02*x1520))+((x1515*x1519))+(((-1.0)*cj0*x1516*x1524))+(((-1.0)*x1521*x1528)));
evalcond[2]=((((-1.0)*r12*x1520))+((sj0*x1531))+(((-1.0)*sj0*x1516*x1524))+(((-1.0)*x1528*x1530))+(((-1.0)*r10*x1533)));
evalcond[3]=((((-1.0)*cj3*x1520*x1529))+((sj3*x1522))+x1531+((r22*x1517))+(((-1.0)*x1516*x1524))+(((-1.0)*r20*x1532))+(((-1.0)*r20*x1520*x1525)));
evalcond[4]=((((-1.0)*cj3*x1520*x1521))+((sj3*x1527))+(((-1.0)*r00*x1532))+(((-1.0)*r00*x1520*x1525))+((x1516*x1519))+((r02*x1517))+((cj0*x1535)));
evalcond[5]=(((sj3*x1518))+(((-1.0)*cj3*x1520*x1530))+((r12*x1517))+((sj0*x1535))+x1539+(((-1.0)*r10*x1532))+(((-1.0)*r10*x1520*x1525)));
evalcond[6]=((((-1.0)*sj1*x1534))+(((-0.3125)*sj1))+(((0.0075)*x1522))+(((0.0675)*x1531))+(((-1.0)*pz))+(((-0.38609)*x1536))+(((-0.38609)*x1535))+(((-1.0)*r20*x1526)));
evalcond[7]=((((-1.0)*r00*x1526))+(((0.38609)*x1515*x1519))+((x1519*x1534))+(((0.0075)*x1527))+(((0.001)*sj0))+(((0.3125)*x1519))+(((-1.0)*px))+(((-1.0)*sj1*x1516*x1523))+((cj0*x1537)));
evalcond[8]=(((cj1*sj0*x1534))+(((0.3125)*cj1*sj0))+(((0.0075)*x1518))+(((-0.001)*cj0))+((sj0*x1537))+(((-1.0)*py))+(((-0.38609)*x1538))+(((0.38609)*sj0*x1531))+(((-1.0)*r10*x1526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1540=((1.0)*sj5);
IkReal x1541=(r20*sj0);
IkReal x1542=((1.0)*cj5);
IkReal x1543=(r21*sj0);
CheckValue<IkReal> x1544=IKPowWithIntegerCheck(IKsign(((((-1.0)*r10*sj4*x1540))+(((-1.0)*r11*sj4*x1542))+(((-1.0)*cj4*r12)))),-1);
if(!x1544.valid){
continue;
}
CheckValue<IkReal> x1545 = IKatan2WithCheck(IkReal((((sj5*x1543))+(((-1.0)*x1541*x1542)))),IkReal((((r22*sj0*sj4))+(((-1.0)*cj4*x1542*x1543))+(((-1.0)*cj4*x1540*x1541)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1545.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1544.value)))+(x1545.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1546=IKsin(j3);
IkReal x1547=IKcos(j3);
IkReal x1548=(sj5*x1547);
IkReal x1549=(cj4*cj5*x1546);
IkReal x1550=(cj4*sj5*x1546);
IkReal x1551=((1.0)*cj5*x1547);
IkReal x1552=((1.0)*sj4*x1546);
evalcond[0]=((((-1.0)*r22*x1552))+((r21*x1548))+((r21*x1549))+(((-1.0)*r20*x1551))+((r20*x1550)));
evalcond[1]=(cj0+((r11*x1549))+((r11*x1548))+(((-1.0)*r12*x1552))+((r10*x1550))+(((-1.0)*r10*x1551)));
evalcond[2]=(((r00*x1550))+(((-1.0)*sj0))+(((-1.0)*r02*x1552))+(((-1.0)*r00*x1551))+((r01*x1548))+((r01*x1549)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1553=(cj4*r12);
IkReal x1554=(pz*sj0);
IkReal x1555=(sj0*sj5);
IkReal x1556=((0.03)*r21);
IkReal x1557=((4.63308)*sj4);
IkReal x1558=(cj5*sj0);
IkReal x1559=((0.09)*r21);
IkReal x1560=(cj0*sj5);
IkReal x1561=(cj4*r22);
IkReal x1562=(cj4*r02);
IkReal x1563=((1.54436)*cj0);
IkReal x1564=(r21*sj4);
IkReal x1565=(cj0*pz);
IkReal x1566=(cj0*cj5*r20);
IkReal x1567=(cj5*r11*sj4);
IkReal x1568=((0.27)*sj4*sj5);
IkReal x1569=((1.54436)*r20*sj4);
IkReal x1570=(cj5*r01*sj4);
IkReal x1571=((0.81)*sj4*sj5);
j1eval[0]=((((5.0)*(IKabs(cj0))))+(((5.0)*(IKabs(sj0))))+(IKabs((((cj0*cj5*r21*x1557))+(((-12.0)*x1565))+(((0.81)*x1570))+(((0.81)*x1562))+((r20*x1557*x1560))+(((-0.09)*x1566))+((x1559*x1560))+(((4.63308)*cj0*x1561))+((r00*x1571)))))+(IKabs((((x1555*x1559))+(((4.63308)*sj0*x1561))+(((0.81)*x1567))+(((-12.0)*x1554))+(((0.81)*x1553))+(((-0.09)*r20*x1558))+((r20*x1555*x1557))+((r21*x1557*x1558))+((r10*x1571)))))+(((0.5)*(IKabs((((x1555*x1569))+((x1555*x1556))+(((0.27)*x1553))+(((-4.0)*x1554))+(((0.27)*x1567))+(((-0.03)*r20*x1558))+(((1.54436)*x1558*x1564))+(((1.54436)*sj0*x1561))+((r10*x1568)))))))+(((0.5)*(IKabs((((x1560*x1569))+((x1556*x1560))+(((-4.0)*x1565))+(((0.27)*x1570))+(((0.27)*x1562))+((cj5*x1563*x1564))+((x1561*x1563))+((r00*x1568))+(((-0.03)*x1566))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1572=(cj5*sj4);
IkReal x1573=(cj0*sj5);
IkReal x1574=(r20*sj4);
IkReal x1575=(cj0*r21);
IkReal x1576=(cj4*r02);
IkReal x1577=(cj0*pz);
IkReal x1578=((-2.5)*cj0);
IkReal x1579=(cj0*cj4*r22);
IkReal x1580=(cj0*cj5*r20);
IkReal x1581=(r00*sj4*sj5);
IkReal x1582=((((0.81)*r01*x1572))+(((4.63308)*x1579))+(((-12.0)*x1577))+(((-0.09)*x1580))+(((0.81)*x1576))+(((0.81)*x1581))+(((0.09)*r21*x1573))+(((4.63308)*x1573*x1574))+(((4.63308)*x1572*x1575)));
IkReal x1583=((((-4.0)*x1577))+(((0.27)*x1581))+(((0.03)*r21*x1573))+(((0.27)*x1576))+(((0.27)*r01*x1572))+(((1.54436)*x1573*x1574))+(((1.54436)*x1572*x1575))+(((1.54436)*x1579))+(((-0.03)*x1580)));
op[0]=x1583;
op[1]=x1578;
op[2]=x1582;
op[3]=((-5.0)*cj0);
op[4]=x1582;
op[5]=x1578;
op[6]=x1583;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1584=(cj4*r12);
IkReal x1585=((2.5)*sj0);
IkReal x1586=(sj0*sj5);
IkReal x1587=(r20*sj4);
IkReal x1588=(cj5*sj0);
IkReal x1589=(r21*sj4);
IkReal x1590=(pz*sj0);
IkReal x1591=((0.27)*x1584);
IkReal x1592=((4.0)*x1590);
IkReal x1593=(cj5*r11*sj4);
IkReal x1594=(cj4*r22*sj0);
IkReal x1595=(r10*sj4*sj5);
IkReal x1596=((1.54436)*x1594);
IkReal x1597=((0.27)*x1593);
IkReal x1598=((0.27)*x1595);
IkReal x1599=((0.03)*r21*x1586);
IkReal x1600=((0.03)*r20*x1588);
IkReal x1601=((1.54436)*x1586*x1587);
IkReal x1602=((1.54436)*x1588*x1589);
IkReal x1603=(x1600+x1592);
IkReal x1604=(x1601+x1602+x1597+x1596+x1591+x1599+x1598);
IkReal x1605=((((-12.0)*x1590))+(((0.81)*x1584))+(((0.81)*x1595))+(((0.81)*x1593))+(((0.09)*r21*x1586))+(((4.63308)*x1588*x1589))+(((-0.09)*r20*x1588))+(((4.63308)*x1586*x1587))+(((4.63308)*x1594)));
j1evalpoly[0]=((((-1.0)*x1603))+x1604+((x1605*(htj1*htj1)))+(((-5.0)*sj0*(htj1*htj1*htj1)))+((x1605*(htj1*htj1*htj1*htj1)))+(((-1.0)*x1585*(htj1*htj1*htj1*htj1*htj1)))+(((htj1*htj1*htj1*htj1*htj1*htj1)*(((((-1.0)*x1603))+x1604))))+(((-1.0)*htj1*x1585)));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1606=((1.0)*cj1);
IkReal x1607=(cj4*r22);
IkReal x1608=(r20*sj5);
IkReal x1609=(sj1*sj4);
IkReal x1610=(cj3*r22);
IkReal x1611=(cj5*r21);
IkReal x1612=((1.0)*sj1);
IkReal x1613=(cj3*cj4);
IkReal x1614=(cj1*x1613);
IkReal x1615=(cj5*r20*sj3);
IkReal x1616=(r21*sj3*sj5);
if( IKabs(((((-1.0)*x1611*x1612*x1613))+(((-1.0)*sj4*x1606*x1608))+(((-1.0)*sj4*x1606*x1611))+((sj1*x1616))+((x1609*x1610))+(((-1.0)*x1608*x1612*x1613))+(((-1.0)*x1606*x1607))+(((-1.0)*x1612*x1615)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1606*x1616))+(((-1.0)*x1609*x1611))+(((-1.0)*sj4*x1606*x1610))+((x1608*x1614))+(((-1.0)*x1607*x1612))+((x1611*x1614))+((cj1*x1615))+(((-1.0)*x1608*x1609)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1611*x1612*x1613))+(((-1.0)*sj4*x1606*x1608))+(((-1.0)*sj4*x1606*x1611))+((sj1*x1616))+((x1609*x1610))+(((-1.0)*x1608*x1612*x1613))+(((-1.0)*x1606*x1607))+(((-1.0)*x1612*x1615))))+IKsqr(((((-1.0)*x1606*x1616))+(((-1.0)*x1609*x1611))+(((-1.0)*sj4*x1606*x1610))+((x1608*x1614))+(((-1.0)*x1607*x1612))+((x1611*x1614))+((cj1*x1615))+(((-1.0)*x1608*x1609))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x1611*x1612*x1613))+(((-1.0)*sj4*x1606*x1608))+(((-1.0)*sj4*x1606*x1611))+((sj1*x1616))+((x1609*x1610))+(((-1.0)*x1608*x1612*x1613))+(((-1.0)*x1606*x1607))+(((-1.0)*x1612*x1615))), ((((-1.0)*x1606*x1616))+(((-1.0)*x1609*x1611))+(((-1.0)*sj4*x1606*x1610))+((x1608*x1614))+(((-1.0)*x1607*x1612))+((x1611*x1614))+((cj1*x1615))+(((-1.0)*x1608*x1609))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1617=IKcos(j2);
IkReal x1618=IKsin(j2);
IkReal x1619=(cj3*sj4);
IkReal x1620=(r11*sj5);
IkReal x1621=(cj0*cj1);
IkReal x1622=((1.0)*cj4);
IkReal x1623=(cj5*r01);
IkReal x1624=(r21*sj5);
IkReal x1625=((0.38609)*cj0);
IkReal x1626=((1.0)*sj1);
IkReal x1627=(cj3*sj5);
IkReal x1628=((0.0075)*cj5);
IkReal x1629=(r01*sj5);
IkReal x1630=((1.0)*sj4);
IkReal x1631=(cj5*r21);
IkReal x1632=(cj5*r11);
IkReal x1633=(cj1*x1617);
IkReal x1634=((1.0)*cj5*sj3);
IkReal x1635=(sj5*x1630);
IkReal x1636=((0.0675)*x1618);
IkReal x1637=(sj1*x1617);
IkReal x1638=(cj1*x1618);
IkReal x1639=((0.0675)*x1637);
IkReal x1640=(sj0*sj1*x1618);
IkReal x1641=(sj0*x1638);
evalcond[0]=((((-1.0)*x1617*x1626))+(((-1.0)*x1638))+(((-1.0)*r20*x1635))+(((-1.0)*r22*x1622))+(((-1.0)*x1630*x1631)));
evalcond[1]=((((-1.0)*cj0*x1618*x1626))+(((-1.0)*x1623*x1630))+(((-1.0)*r00*x1635))+((x1617*x1621))+(((-1.0)*r02*x1622)));
evalcond[2]=((((-1.0)*r12*x1622))+(((-1.0)*sj0*x1618*x1626))+((sj0*x1633))+(((-1.0)*r10*x1635))+(((-1.0)*x1630*x1632)));
evalcond[3]=((((-1.0)*cj3*x1622*x1631))+(((-1.0)*r20*x1622*x1627))+((sj3*x1624))+x1633+(((-1.0)*r20*x1634))+((r22*x1619))+(((-1.0)*x1618*x1626)));
evalcond[4]=(((sj3*x1629))+(((-1.0)*r00*x1634))+(((-1.0)*r00*x1622*x1627))+((cj0*x1637))+((x1618*x1621))+(((-1.0)*cj3*x1622*x1623))+((r02*x1619)));
evalcond[5]=((((-1.0)*cj3*x1622*x1632))+((sj0*x1637))+((sj3*x1620))+x1641+((r12*x1619))+(((-1.0)*r10*x1634))+(((-1.0)*r10*x1622*x1627)));
evalcond[6]=((((-1.0)*sj1*x1636))+(((-1.0)*r20*x1628))+(((-0.3125)*sj1))+(((0.0675)*x1633))+(((-1.0)*pz))+(((0.0075)*x1624))+(((-0.38609)*x1637))+(((-0.38609)*x1638)));
evalcond[7]=(((x1621*x1636))+(((-1.0)*r00*x1628))+(((0.001)*sj0))+(((-1.0)*px))+((cj0*x1639))+(((0.38609)*x1617*x1621))+(((-1.0)*sj1*x1618*x1625))+(((0.0075)*x1629))+(((0.3125)*x1621)));
evalcond[8]=(((sj0*x1639))+(((0.3125)*cj1*sj0))+(((-0.001)*cj0))+(((-1.0)*py))+(((0.38609)*sj0*x1633))+(((-1.0)*r10*x1628))+((cj1*sj0*x1636))+(((0.0075)*x1620))+(((-0.38609)*x1640)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1642=((1.0)*sj4);
IkReal x1643=(cj0*r21);
IkReal x1644=((1.0)*cj5);
IkReal x1645=(cj0*r20);
IkReal x1646=((1.0)*cj4);
CheckValue<IkReal> x1647=IKPowWithIntegerCheck(IKsign(((((-1.0)*cj5*r01*x1642))+(((-1.0)*r00*sj5*x1642))+(((-1.0)*r02*x1646)))),-1);
if(!x1647.valid){
continue;
}
CheckValue<IkReal> x1648 = IKatan2WithCheck(IkReal(((((-1.0)*x1644*x1645))+((sj5*x1643)))),IkReal(((((-1.0)*sj5*x1645*x1646))+((cj0*r22*sj4))+(((-1.0)*cj4*x1643*x1644)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1648.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1647.value)))+(x1648.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1649=IKsin(j3);
IkReal x1650=IKcos(j3);
IkReal x1651=(sj5*x1650);
IkReal x1652=(cj4*cj5*x1649);
IkReal x1653=(cj4*sj5*x1649);
IkReal x1654=((1.0)*cj5*x1650);
IkReal x1655=((1.0)*sj4*x1649);
evalcond[0]=((((-1.0)*r22*x1655))+((r20*x1653))+(((-1.0)*r20*x1654))+((r21*x1651))+((r21*x1652)));
evalcond[1]=(((r10*x1653))+cj0+(((-1.0)*r10*x1654))+((r11*x1651))+((r11*x1652))+(((-1.0)*r12*x1655)));
evalcond[2]=((((-1.0)*sj0))+(((-1.0)*r00*x1654))+((r01*x1652))+((r01*x1651))+((r00*x1653))+(((-1.0)*r02*x1655)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[1];
IkReal x1656=(cj4*r12);
IkReal x1657=(pz*sj0);
IkReal x1658=(sj0*sj5);
IkReal x1659=((0.03)*r21);
IkReal x1660=((4.63308)*sj4);
IkReal x1661=(cj5*sj0);
IkReal x1662=((0.09)*r21);
IkReal x1663=(cj0*sj5);
IkReal x1664=(cj4*r22);
IkReal x1665=(cj4*r02);
IkReal x1666=((1.54436)*cj0);
IkReal x1667=(r21*sj4);
IkReal x1668=(cj0*pz);
IkReal x1669=(cj0*cj5*r20);
IkReal x1670=(cj5*r11*sj4);
IkReal x1671=((0.27)*sj4*sj5);
IkReal x1672=((1.54436)*r20*sj4);
IkReal x1673=(cj5*r01*sj4);
IkReal x1674=((0.81)*sj4*sj5);
j1eval[0]=((((0.5)*(IKabs(((((0.27)*x1665))+((r00*x1671))+(((-0.03)*x1669))+(((-4.0)*x1668))+((x1659*x1663))+((cj5*x1666*x1667))+((x1663*x1672))+((x1664*x1666))+(((0.27)*x1673)))))))+(IKabs((((r00*x1674))+(((4.63308)*cj0*x1664))+(((-12.0)*x1668))+((cj0*cj5*r21*x1660))+((x1662*x1663))+(((-0.09)*x1669))+(((0.81)*x1665))+(((0.81)*x1673))+((r20*x1660*x1663)))))+(((5.0)*(IKabs(cj0))))+(((5.0)*(IKabs(sj0))))+(IKabs(((((-12.0)*x1657))+(((4.63308)*sj0*x1664))+(((0.81)*x1656))+((r10*x1674))+((r21*x1660*x1661))+((x1658*x1662))+((r20*x1658*x1660))+(((0.81)*x1670))+(((-0.09)*r20*x1661)))))+(((0.5)*(IKabs(((((-4.0)*x1657))+((x1658*x1659))+((r10*x1671))+(((1.54436)*sj0*x1664))+((x1658*x1672))+(((0.27)*x1656))+(((-0.03)*r20*x1661))+(((1.54436)*x1661*x1667))+(((0.27)*x1670))))))));
if( IKabs(j1eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j1, j2]

} else
{
IkReal op[6+1], zeror[6];
int numroots;
IkReal j1evalpoly[1];
IkReal x1675=(cj5*sj4);
IkReal x1676=(cj0*sj5);
IkReal x1677=(r20*sj4);
IkReal x1678=(cj0*r21);
IkReal x1679=(cj4*r02);
IkReal x1680=(cj0*pz);
IkReal x1681=((-2.5)*cj0);
IkReal x1682=(cj0*cj4*r22);
IkReal x1683=(cj0*cj5*r20);
IkReal x1684=(r00*sj4*sj5);
IkReal x1685=((((0.09)*r21*x1676))+(((4.63308)*x1675*x1678))+(((0.81)*r01*x1675))+(((4.63308)*x1676*x1677))+(((-0.09)*x1683))+(((0.81)*x1684))+(((-12.0)*x1680))+(((0.81)*x1679))+(((4.63308)*x1682)));
IkReal x1686=((((1.54436)*x1676*x1677))+(((0.27)*r01*x1675))+(((0.27)*x1684))+(((0.03)*r21*x1676))+(((1.54436)*x1682))+(((-4.0)*x1680))+(((-0.03)*x1683))+(((1.54436)*x1675*x1678))+(((0.27)*x1679)));
op[0]=x1686;
op[1]=x1681;
op[2]=x1685;
op[3]=((-5.0)*cj0);
op[4]=x1685;
op[5]=x1681;
op[6]=x1686;
polyroots6(op,zeror,numroots);
IkReal j1array[6], cj1array[6], sj1array[6], tempj1array[1];
int numsolutions = 0;
for(int ij1 = 0; ij1 < numroots; ++ij1)
{
IkReal htj1 = zeror[ij1];
tempj1array[0]=((2.0)*(atan(htj1)));
for(int kj1 = 0; kj1 < 1; ++kj1)
{
j1array[numsolutions] = tempj1array[kj1];
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
numsolutions++;
}
}
bool j1valid[6]={true,true,true,true,true,true};
_nj1 = 6;
for(int ij1 = 0; ij1 < numsolutions; ++ij1)
    {
if( !j1valid[ij1] )
{
    continue;
}
    j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
htj1 = IKtan(j1/2);

IkReal x1687=(cj4*r12);
IkReal x1688=((2.5)*sj0);
IkReal x1689=(sj0*sj5);
IkReal x1690=(r20*sj4);
IkReal x1691=(cj5*sj0);
IkReal x1692=(r21*sj4);
IkReal x1693=(pz*sj0);
IkReal x1694=((0.27)*x1687);
IkReal x1695=((4.0)*x1693);
IkReal x1696=(cj5*r11*sj4);
IkReal x1697=(cj4*r22*sj0);
IkReal x1698=(r10*sj4*sj5);
IkReal x1699=((1.54436)*x1697);
IkReal x1700=((0.27)*x1696);
IkReal x1701=((0.27)*x1698);
IkReal x1702=((0.03)*r21*x1689);
IkReal x1703=((0.03)*r20*x1691);
IkReal x1704=((1.54436)*x1689*x1690);
IkReal x1705=((1.54436)*x1691*x1692);
IkReal x1706=(x1703+x1695);
IkReal x1707=(x1700+x1701+x1702+x1704+x1705+x1694+x1699);
IkReal x1708=((((-0.09)*r20*x1691))+(((4.63308)*x1697))+(((0.81)*x1696))+(((0.81)*x1698))+(((-12.0)*x1693))+(((0.81)*x1687))+(((4.63308)*x1689*x1690))+(((0.09)*r21*x1689))+(((4.63308)*x1691*x1692)));
j1evalpoly[0]=(x1707+(((-1.0)*x1688*(htj1*htj1*htj1*htj1*htj1)))+(((-1.0)*htj1*x1688))+(((-5.0)*sj0*(htj1*htj1*htj1)))+(((-1.0)*x1706))+(((htj1*htj1*htj1*htj1*htj1*htj1)*((x1707+(((-1.0)*x1706))))))+((x1708*(htj1*htj1)))+((x1708*(htj1*htj1*htj1*htj1))));
if( IKabs(j1evalpoly[0]) > 0.0000001000000000  )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < numsolutions; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x1709=((1.0)*cj1);
IkReal x1710=(cj4*r22);
IkReal x1711=(r20*sj5);
IkReal x1712=(sj1*sj4);
IkReal x1713=(cj3*r22);
IkReal x1714=(cj5*r21);
IkReal x1715=((1.0)*sj1);
IkReal x1716=(cj3*cj4);
IkReal x1717=(cj1*x1716);
IkReal x1718=(cj5*r20*sj3);
IkReal x1719=(r21*sj3*sj5);
if( IKabs(((((-1.0)*sj4*x1709*x1714))+(((-1.0)*sj4*x1709*x1711))+((x1712*x1713))+(((-1.0)*x1711*x1715*x1716))+(((-1.0)*x1709*x1710))+(((-1.0)*x1714*x1715*x1716))+(((-1.0)*x1715*x1718))+((sj1*x1719)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x1710*x1715))+(((-1.0)*sj4*x1709*x1713))+((cj1*x1718))+((x1714*x1717))+(((-1.0)*x1709*x1719))+((x1711*x1717))+(((-1.0)*x1711*x1712))+(((-1.0)*x1712*x1714)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj4*x1709*x1714))+(((-1.0)*sj4*x1709*x1711))+((x1712*x1713))+(((-1.0)*x1711*x1715*x1716))+(((-1.0)*x1709*x1710))+(((-1.0)*x1714*x1715*x1716))+(((-1.0)*x1715*x1718))+((sj1*x1719))))+IKsqr(((((-1.0)*x1710*x1715))+(((-1.0)*sj4*x1709*x1713))+((cj1*x1718))+((x1714*x1717))+(((-1.0)*x1709*x1719))+((x1711*x1717))+(((-1.0)*x1711*x1712))+(((-1.0)*x1712*x1714))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*sj4*x1709*x1714))+(((-1.0)*sj4*x1709*x1711))+((x1712*x1713))+(((-1.0)*x1711*x1715*x1716))+(((-1.0)*x1709*x1710))+(((-1.0)*x1714*x1715*x1716))+(((-1.0)*x1715*x1718))+((sj1*x1719))), ((((-1.0)*x1710*x1715))+(((-1.0)*sj4*x1709*x1713))+((cj1*x1718))+((x1714*x1717))+(((-1.0)*x1709*x1719))+((x1711*x1717))+(((-1.0)*x1711*x1712))+(((-1.0)*x1712*x1714))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[9];
IkReal x1720=IKcos(j2);
IkReal x1721=IKsin(j2);
IkReal x1722=(cj3*sj4);
IkReal x1723=(r11*sj5);
IkReal x1724=(cj0*cj1);
IkReal x1725=((1.0)*cj4);
IkReal x1726=(cj5*r01);
IkReal x1727=(r21*sj5);
IkReal x1728=((0.38609)*cj0);
IkReal x1729=((1.0)*sj1);
IkReal x1730=(cj3*sj5);
IkReal x1731=((0.0075)*cj5);
IkReal x1732=(r01*sj5);
IkReal x1733=((1.0)*sj4);
IkReal x1734=(cj5*r21);
IkReal x1735=(cj5*r11);
IkReal x1736=(cj1*x1720);
IkReal x1737=((1.0)*cj5*sj3);
IkReal x1738=(sj5*x1733);
IkReal x1739=((0.0675)*x1721);
IkReal x1740=(sj1*x1720);
IkReal x1741=(cj1*x1721);
IkReal x1742=((0.0675)*x1740);
IkReal x1743=(sj0*sj1*x1721);
IkReal x1744=(sj0*x1741);
evalcond[0]=((((-1.0)*x1733*x1734))+(((-1.0)*r22*x1725))+(((-1.0)*x1720*x1729))+(((-1.0)*x1741))+(((-1.0)*r20*x1738)));
evalcond[1]=((((-1.0)*x1726*x1733))+(((-1.0)*r00*x1738))+((x1720*x1724))+(((-1.0)*cj0*x1721*x1729))+(((-1.0)*r02*x1725)));
evalcond[2]=((((-1.0)*x1733*x1735))+(((-1.0)*r10*x1738))+(((-1.0)*r12*x1725))+((sj0*x1736))+(((-1.0)*sj0*x1721*x1729)));
evalcond[3]=(((sj3*x1727))+(((-1.0)*r20*x1725*x1730))+x1736+((r22*x1722))+(((-1.0)*cj3*x1725*x1734))+(((-1.0)*r20*x1737))+(((-1.0)*x1721*x1729)));
evalcond[4]=(((x1721*x1724))+(((-1.0)*r00*x1737))+((r02*x1722))+(((-1.0)*cj3*x1725*x1726))+(((-1.0)*r00*x1725*x1730))+((cj0*x1740))+((sj3*x1732)));
evalcond[5]=(((sj3*x1723))+(((-1.0)*r10*x1737))+x1744+(((-1.0)*r10*x1725*x1730))+(((-1.0)*cj3*x1725*x1735))+((sj0*x1740))+((r12*x1722)));
evalcond[6]=((((0.0675)*x1736))+(((-0.3125)*sj1))+(((-0.38609)*x1740))+(((-0.38609)*x1741))+(((-1.0)*pz))+(((0.0075)*x1727))+(((-1.0)*sj1*x1739))+(((-1.0)*r20*x1731)));
evalcond[7]=(((x1724*x1739))+(((0.3125)*x1724))+(((0.38609)*x1720*x1724))+(((-1.0)*r00*x1731))+(((0.001)*sj0))+(((-1.0)*sj1*x1721*x1728))+(((-1.0)*px))+(((0.0075)*x1732))+((cj0*x1742)));
evalcond[8]=((((0.3125)*cj1*sj0))+(((-1.0)*r10*x1731))+((cj1*sj0*x1739))+(((-0.001)*cj0))+(((-0.38609)*x1743))+(((-1.0)*py))+(((0.0075)*x1723))+(((0.38609)*sj0*x1736))+((sj0*x1742)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
    }

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "32bbb8de3028d9e3c090492233eb0f90"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
